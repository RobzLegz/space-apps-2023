{"pdf_text_combined": "NASA TECHNICAL  HANDBOOK  National Aeronautics and Space Administration  Washington, DC 20546-0001     MEASUREMENT SYSTEM IDENTIFICATION:  METRIC/SI                    Document  Revision                       This Handbook is published by the National Aeronautics and Space Administration (NASA) as a  guidance document to provide engineering information; lessons learned; possible options to address  technical issues; classification of similar items, materials, or processes; interpretative direction and  techniques; and any other type of guidance information that may help the Government or its  contractors in the design, construction, selection, management, support, or operation of systems,  products, processes, or services.  his Handbook establishes programmable logic design engineering guidanceIt originated from  multiple requests for additional guidance, rationale, resources, references and lessons learned for  acquiring, managing, developing, assuring and maintaining NASA systems.  This Handbook is approved for use by NASA Headquarters and NASA Centers, including  Component Facilities and Technical and Service Support Centers.   \u201cFeedback\u201d in the NASA Standards and Technical Assistance Resource Tool at  https://standards.nasa.gov.   Michael G. Ryschkewitsch  NASA Chief Engineer                                       DOCUMENT HISTORY LOG ...........................................................................................  FOREWORD .......................................................................................................................  TABLE OF CONTENTS .....................................................................................................  LIST OF FIGURES .............................................................................................................  LIST OF TABLES ...............................................................................................................   2   3   4   7  7    1.  1.1  1.2  2.  2.1  2.2  2.3  2.4  3.  3.1  3.2  4.  4.1  5.  5.1  5.2  5.3  5.4  6.  6.1  6.2  6.3  6.4  6.5  7.  7.1  7.2  SCOPE .................................................................................................................  Purpose .................................................................................................................  Applicability .........................................................................................................   8   8   8  APPLICABLE DOCUMENTS .........................................................................  General ..................................................................................................................  Government Documents .......................................................................................  Non-Government Documents ...............................................................................  Order of Precedence .............................................................................................   9   9   9   9   9  ACRONYMS AND DEFINITIONS ..................................................................  Acronyms and Abbreviations ...............................................................................  Definitions ............................................................................................................   10   10   12  LIFE CYCLE AND DEVICE DEVELOPMENT ...........................................  Life Cycle Definitions ..........................................................................................   14   14  PLANNING AND REQUIREMENTS PHASE ...............................................  Roles and Responsibilities ....................................................................................  The Development Plan .........................................................................................  Requirements ........................................................................................................  Verification Plan ...................................................................................................  PRELIMINARY DESIGN PHASE ..................................................................  Entry Criteria ........................................................................................................  Design Specification (Preliminary Version) .........................................................  Interface Definition (Preliminary Version) ..........................................................  Use of Intellectual Property (In-House or Out-of-House) ....................................  Exit Criteria ..........................................................................................................   17   17   20   29   30   33   33   33   34   34   35  DETAILED DESIGN PHASE ...........................................................................  Entry Criteria ........................................................................................................  Coding Standard ...................................................................................................   35   35   36                                      7.3  7.4  7.5  7.6  7.7  7.8  8.  8.1  8.2  8.3  8.4  8.5  8.6  8.7  9.  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  10.  10.1  10.2  11.  11.1  11.2  11.3  11.4  Design Standard/Best Practices ............................................................................  Design Specification .............................................................................................  Board and PLD Interface Considerations .............................................................  Design Test Coverage ...........................................................................................  Software Development for an Embedded Processor ............................................  Exit Criteria ..........................................................................................................  DESIGN IMPLEMENTATION PHASE .........................................................  Entry Criteria ........................................................................................................  Implementation .....................................................................................................  Verification Preparation .......................................................................................  Synthesis and Timing Analysis ............................................................................  Baseline Work Products .......................................................................................  Generate the Programming File ............................................................................  Exit Criteria ..........................................................................................................  VERIFICATION ................................................................................................  Entry Criteria ........................................................................................................  Test Process ..........................................................................................................  Simulation .............................................................................................................  Independent Peer Verification ..............................................................................  Verification Review ..............................................................................................  Regression Testing ...............................................................................................  Hardware Verification ..........................................................................................  Exit Criteria ..........................................................................................................   36   48   50   51   51   51   51   51   52   52   53   60   60   62   62   63   63   64   67   69   70   70   71  DELIVERY .........................................................................................................  PLD Programming ................................................................................................  PLD Marking ........................................................................................................   72   74   75  MAINTENANCE ................................................................................................  Design Libraries ...................................................................................................  Active Designs ......................................................................................................  Post-Delivery Anomalies ......................................................................................  Retired Designs .....................................................................................................   75   75   76   76   76                                   13.  13.1  13.2  OUT-OF-HOUSE CONSIDERATIONS ..........................................................  Contract Statement of Work (SOW) ....................................................................  The Flight PLD Design Review Process ..............................................................   77   77   78   A  B  C  D  E  F  G  Suggested Source Code Header and Footer Template .........................................  Sample Peer Review Checklists ...........................................................................  Customizing ..........................................................................................................  Life Cycle Product Guidance ...............................................................................  Safety Critical .......................................................................................................  Board Level Design Considerations .....................................................................  Guidance ...............................................................................................................   82   84   100   104   105   107   121                      1  2  3  4  5  6  7  PLD Life Cycle Development Phases ..................................................................  Example Development Team Role-Based Organization Chart ............................  Sample Clock Tree Diagram ................................................................................  Flight Project PLD Design Review Process .........................................................  Recommended Power-On Reset Implementation .................................................  Glitches Due to Input Slew Rate Violations .........................................................  Sneak Path in Some LSTTL from Output to VCC .................................................   15   20   49   79   108   112   114     1  2  3  4  5  6  7  List of Possible Reviews .......................................................................................  Sample Verification Matrix ..................................................................................  Example of Two-Corner Analysis ........................................................................  Regression Testing ...............................................................................................  PLD Classification ................................................................................................  PLD Development Customization Recommendations .........................................  Guidance for PLD Life Cycle Products at Various Reviews ...............................   28   32   56   70   100   102   104                           maintaining programmable logic devices (PLDs). Additionally, best practices are recommended  for different PLD development phases. This Handbook provides guidance to perform project  activities. It covers all aspects of the design cycle from initial planning through release and  maintenance. The specific types of PLDs this Handbook addresses are as follows:      Field-programmable gate array (FPGA).  \u2022 Complex programmable logic device (CPLD).      he development of successful PLDs requires a coordinated effort. This Handbook contains  guidelines that provide for a consistent approach based on best practices for the development of  PLDs for flight and ground support systems across NASA Centers. The advancing technology in  PLDs has allowed for the implementation of more complex designs in single devices. Many of  these devices designed within NASA systems perform critical operations. The guidelines in this  Handbook serve to increase confidence in the quality of PLD designs.  the design, development, and verification of these systems. Hardware designers are now  expected to implement PLD designs that are as complex as traditional microprocessor-based  systems that were designed in some cases by large teams of engineers.    Component Facilities and Technical and Service Support Centers. This Handbook may also apply to  the Jet Propulsion Laboratory or to other contractors, grant recipients, or parties to agreements only  to the extent specified or referenced in their contracts, grants, or agreements.   his Handbook provides engineering guidance applicable to programmable logic design. It  serves as a primer for sound engineering design practice and can be used in its entirety, or in  portions thereof, in conjunction with other available design resources.              This Handbook, or portions thereof, may be referenced in contract, program, and other Agency  documents for guidance. When this Handbook contains procedural or process requirements, they  may be cited in contract, program, and other Agency documents for guidance.    .1.2 Non-use of specific versions as designated shall be approved by the responsible Technical  Authority.   Resource Tool at http://standards.nasa.gov or may be obtained directly from the Standards  Developing Organizations or other document distributors. Additional documents and design  resources are available at https://nen.nasa.gov/web/pld.   .1.1 The latest issuances of cited documents shall apply unless specific versions are  designated.         programmable logic devices but does not supersede nor waive established Agency  requirements/guidance found in other documentation.                    A/D  AID  ASIC  CDC  CDR  CLK  CLKA/B  CLKBUF  CM  CMOS  COTS  CPLD  CPU  CRC  CVS  CxP  DC  DDP  DDR  DFF  DLL  DOORS  EDAC  EEPROM  EIDP  EMI  ESD  ETU  FET  FIFO  FPGA  FSM  GIDEP  GPU  HALE  HCLK  HCLKBUF  HDL  HSI  I/O  IC  analog to digital  altered item drawing  application specific integrated circuit  clock domain crossing  critical design review  clock  clock A or B  clock buffer  configuration management  complementary metal oxide semiconductor  commercial off the shelf  complex programmable logic device  central processing unit  cyclic redundancy check  Concurrent Versions System  Constellation Program  direct current  detailed design phase  double data rate  d-flip-flop  delay-locked loop  Dynamic Object-Oriented Requirements System  error detection and correction  electrically erasable programmable read-only memory  end item data package  electromagnetic interference  electrostatic discharge  engineering test unit  field effect transistor  first in, first out  field-programmable gate array  finite state machine  Government Industry Data Exchange Program  graphics processing unit  high altitude long endurance  hardwired CLK driver  buffer for HCLK  hardware description language  hardware/software integration  input/output  integrated circuit               IP  ITAR  JTAG  LSTTL  LVDS  ms  N/C  NASA  ns  OTS  PCB  PCI  PDP  PDR  PLD  PLL  PnR  POC  POR  PROM  PRP  QA  RDD  ROM  RTL  SDF  SERDES  SET  SEU  SMA  SOW  SRAM  SSO  STA  SVN  TBD  TID  TMR  TRST  TTL  UART  VDD    intellectual property  International Traffic in Arms Regulations  Joint Test Action Group  Low-power Schottky Transistor Transistor Logic  low voltage differential signaling  millisecond  no connect  National Aeronautics and Space Administration  nanosecond  off-the-shelf  printed circuit board  peripheral component interconnect  preliminary design phase  preliminary design review  programmable logic device  phase-locked loop  place and route  point of contact  power-on reset  programmable read-only memory  planning and requirements phase  quality assurance  revision description document  read-only memory  register-transfer level  Standard Delay Format  serializer-deserializer  single event transient  single event upset  Safety and Mission Assurance  statement of work  static random access memory  simultaneously switching output  static timing analysis  Subversion  to be determined  total ionizing dose  triple modular redundancy  test reset (JTAG test reset signal)  transistor-transistor logic  universal asynchronous receiver/transmitter  Version Description Document  very high speed integrated circuit (VHSIC) hardware  description language (HDL)                 frequency that may differ from the frequency of other blocks on the same chip. A clock domain  crossing occurs whenever data is transferred from a flop driven by one clock to a flop driven by  another clock.   A cold sparing device is designed to allow powered input signals to be applied to the unpowered  device without damage to the device.   transmission system creates an undesired effect in another circuit or channel. Note: Undesired  capacitive, inductive, or conductive coupling from one circuit, part of a circuit, or channel to  another is what usually causes crosstalk.              VHSIC  VIO  VP  very high speed integrated circuit  voltage input/output  verification phase         Hystereis: A phenomenon wherein two (or more) physical quantities bear a relationship  that depends on prior history. More specifically, the response Y takes on different values for an  increasing input X than for a decreasing X.   Metastability: The ability of a digital electronic system to persist for an unbounded time  in an unstable equilibrium or metastable state. In metastable states, the circuit may be unable to  settle into a stable '0' or '1' logic level within the time required for proper circuit operation. As a  result, the circuit can act in unpredictable ways, and may lead to a system failure.   will be connected together in a specific way on your PLD in order to fulfill your design as  specified. For FPGAs, the most basic primitives are flip-flops and lookup tables.     Synthesis: A process that starts from a high level of logic abstraction (typically Verilog  or Very High Speed Integrated Circuit (VHSIC) Hardware Description Language (VHDL)) and  automatically creates a lower level of logic abstraction using a library containing primitives.   under test and the stimulus provided by the test bench. Note: A test bench is a Hardware  Description Language (HDL) code that allows the designer to provide a documented, repeatable  set of stimuli that is portable across different simulators. A test bench can be as simple as a file  with clock and input data or a more complicated file that includes error checking, file input and  output, and conditional testing. Verilog designers sometimes refer to a Verilog test fixture.  \u201cTest bench\u201d and \u201ctest fixture\u201d are used synonymously throughout this Handbook.                       entry and exit criteria. This section describes this series of development phases and the products  developed in each phase. Depending on the criticality and risk to the project, two or more phases  can be combined into a single phase. Additionally, device development does not typically  consist of a single pass through each phase. The phases iterate based on the needs of the design.        evelopment planning is essential for early identification of all the development needs and risks.  It also provides the PLD design team with a clear view of the near- and long-term objectives and  goals. The planning and requirements phase (PRP) occurs when requirements have been  allocated to the board where the PLD resides. High-level system requirements flow down and  the design team uses them to generate the PLD requirements.  he planning phase includes documenting a development plan that all developers follow. The  plan documents the systematic approach used to manage, design, develop, verify, document, and  review all PLDs delivered. The design team can customize the level of detail to the complexity  of the design and project. Appendix C provides more details on customization.                                During the preliminary design phase (PDP), the design team generates a top-level design based  on the device requirements. This top-level design includes block diagrams and data flow  diagrams that serve as the design architecture. Design trade studies are completed during this  phase. This phase is complete when the stakeholders identified in the PRP approve the  preliminary design. Section 6 describes this phase in greater detail.   DDP, the preliminary design is used to generate a more detailed design based on the  requirements and architecture. This phase iterates as needed with the design implementation  phase to further modify and/or expand until it meets all requirements. This phase is complete  when the stakeholders identified in the PRP approve the documented detailed design. Section 7  describes this phase in greater detail.   uring the design implementation phase, design capture (such as coding in a hardware  description language (HDL)) is completed. The design team performs design simulation,  synthesis, place and route (PnR), and timing analyses. The design may be tested on a  development board and/or hardware resembling the final flight system. This phase iterates with  the DDP as needed. Section 8 describes this phase in greater detail.   Verification determines that the end product meets all of the specified requirements whereas  validation determines the requirements are correct. Validation is beyond the scope of this  document since it often requires a higher level of integration. Verification activities include  reviews, tests, and simulations in accordance with the plan developed in the PRP. Formal  acceptance of the final design occurs at the conclusion of the verification phase (VP). Section 9  describes this phase in greater detail.   After successful verification, the design team releases the completed design for integration into  the next higher-level assembly (e.g., board, box, etc.). Section 10 describes this phase in greater  detail.   The development team continues to provide troubleshooting support for issues deemed  unsolvable by the user of the design, and investigates and tracks potential design anomalies to  completion. Maintenance support covers any issues reported after the delivery. Section 11  describes this phase in greater detail.              Numerous projects do project planning as part of the system planning. All items that are  identified in the PRP can be done separately or as part of the larger planning.     a. A development plan.  b. A requirements document.  c. A verification plan.   Project Management, System Engineering, and the Chief Engineer. The use of NPR7123.1,  NASA Systems Engineering and Process Requirements, continues to serve as the governing  requirements for system development.  The design team applies customization to each of the documents depending on the project.  Appendix C shows a proposed PLD classification to aid in determining an appropriate  customization.    The scope of work for each role on the development team varies with the size and complexity of  the development. A development team member may perform multiple roles for a simple  development. Conversely, multiple individuals might be required to share the responsibilities for  a single role for a large development. Work with the line management to set the initial roles and  responsibilities for the development effort. This can then be worked into the efforts defined by  the project.   1) Co-develop the development plan with the technical development lead.  (2) Manage the development plan.  (3) Manage budget and schedule.  (4) Collect development metrics and provide status to project management.  (5) Manage procurement contracts.  b. PLD Technical Development Lead.   1) Co-develop the development plan with the PLD team lead.  APPROVED FOR PUBLIC RELEASE\u2014DISTRIBUTION IS UNLIMITED                (3) Oversee the technical aspect of the overall development and the end delivery of the  design (including design analyses/trade studies, identifying intellectual property (IP)  core usage, etc.).  (4) Develop, negotiate, and maintain the PLD design requirements.  (5) Select design and configuration management (CM) tools when necessary.  (6) Develop/select the revision control process and associated tools(s).  (7) Owner of the PLD design specification.  (8) Manage design tools (maintenance support, license files, tool availability).  (9) Ensure adherence to the required design process.  (10) Responsible for the overall quality and delivery of the end product.  (11) Assign responsibilities to members of the development team.  (3) Build and release (official and unofficial) design into the test venue and for delivery.  (4) Assemble the end item data package (EIDP) of the official releases.  1) Responsible for the development of the PLD verification plan, including defining test  (hardware and software) requirements, verification items for simulation and pass/fail  criteria for each verification item.    (3) Oversee and ensure the completion of the verification activities.  (4) Archive the verification results.        1) Manage revision control.  (2) Maintain the design repository/library.                the board level and providing a single POC for reporting the testing status to the PLD  development team. The test lead is the source of the testability requirements  (software, test points, fault injection, etc.).  3) Test Equipment Development Lead: Responsible for developing and negotiating the  functional requirements for the test equipment with the technical development lead.  (4) Safety and Mission Assurance (SMA) personnel: Serves as an independent assessor.  NASA-HDBK-8739.23, NASA Complex Electronics Handbook for Assurance  Professional, documents the SMA roles and responsibilities, and they are NOT duplicated  in this document. In addition for safety-critical projects, SMA personnel will also use  NPR 8715.3C, General Safety Program Requirements, for applicability to PLDs.    1) Board Design Lead: Owner of the board where the PLD resides. The board design  lead works with the technical development lead on defining the PLD requirements,  ensures compatible interface between the board and PLD throughout the design  phases, and coordinates the overall verification effort for the board.    (1) Design the assigned design modules.  (2) Generate pertinent documentation for the assigned design modules.  (3) Perform incremental testing.    A. Software developers.  B. Subsystem engineers.  C. System engineers.  D. Test engineers.                 A possible role-based organization chart of the development team is shown in figure 2, Example  Development Team Role-Based Organization Chart, follows.   In addition to the development team, the corresponding delivery organization also plays an  integral role in the development process. It is the delivery organization\u2019s responsibility to:     The PLD design process includes documenting a development plan(s) for the developers to  follow. This plan(s) documents the systematic approach used to manage, design, verify,  document, and review all PLDs delivered. Development planning involves defining several  items that have long-term implications on the project. These can include the following:     a. Development tools.  b. Metrics measurement.  c. Risk management.  d. System safety considerations  e. Configuration management.  f. Training.  APPROVED FOR PUBLIC RELEASE\u2014DISTRIBUTION IS UNLIMITED                   The design team can customize the development plan depending on the complexity and project  requirements. All items listed above do not necessarily require a separate detailed plan. The  team notes each item, the related activities, and issues that affect the cost and schedule. Many  times these plans can be a part of an overall project development plan.      (1) Manufacturer.  (2) Tool.  (3) Version.  (4) Function.  (5) Repository for tool archival.   without sufficient justification (e.g., re-characterization of the targeted device and/or a bug fix  that would affect the functionality of the programmed PLD). When an issue warrants a tool  update, revise the development plan and notify the development team.   (GIDEPs) or manufacturer notices, will be communicated to the design team. This could come  from other discipline areas, such as assurance or parts engineering. This is also applicable to the  PLD itself, not only the programming tool.    g. Schedule.  h. Bug tracking.  i. Project deliverables.  j. Review planning.  k. Roles and Responsibilities.                dvances in today\u2019s technology have allowed PLD capacity to become increasingly dense.  Therefore, PLD designs have also become proportionally more complex. There is a need for  projects and programs to be able to measure the progression of the PLD design toward the final  end product. Metrics measurement allows project management to track PLD design through  design, implementation, verification, and integration.    a. To provide visibility into the design progress.  b. To complete the development per the agreed-upon schedule and budget.  c. To identify programmatic risks.  d. Monitor accepted and rejected design change requests.  The PLD team lead would be responsible for collecting project metrics, storing them in the  project folder, analyzing the measurement data and reporting them periodically. The report may  also contain a summary statement of the metrics pointing out any measurements trending  towards a limit that may indicate a pending problem. Project metrics for each PLD can include:  a. Coverage metrics (code and functional).  b. Design effort (man-hours) \u2013 planned versus actual.  c. Budget \u2013 planned versus actual.  d. Requirements stability \u2013 number of requirements, number of requirements changes,   PLD inputs/outputs (I/Os), static random access memory (SRAM) memory, timing, etc.) \u2013  actual.   . Requirements verification progress (procedures or test benches developed and verified).  g. Number of problem reports and review item discrepancies \u2013 open, closed, and   h. Number of reviews \u2013 planned versus actual.  i. Risks and mitigations.            epending on the size and project requirements of the PLD development, the development team  will want to identify and manage risks. The technical development lead identifies and manages  the risks. Pay special attention to areas such as the following:   afety-critical applications impose requirements on a project\u2019s system safety team to develop  key documents, including a safety data package and a hazard report. For such safety-critical  PLD designs, the PLD team could be tasked with supporting the safety team to provide  information that they can use to document hazards and their mitigation. Hazard identification  could cover safety elements:    a. Device resource utilization.  b. Timing.  c. Power consumption.  d. External interfaces.      NASA requires Safety and Mission Assurance (SMA) to validate the verification of safety  requirements. This can include the witnessing of tests. This validation typically happens at  levels higher than the PLD, such as at box or subsystem level. For those cases where validation  is applied down at the PLD level, PLD verification planning needs to accommodate key  participants such as SMA.   he project or Center defines formal CM for control of released items. At lower levels, the PLD  team or line organization typically establishes a revision control system to manage the changes to  and archiving of working documents and design files. A controlled item is anything submitted to  the revision control or CM system. A typical system needs to incorporate capabilities including  the following:                  b. Method(s) for identifying/marking a controlled item.  c. The process for modifying a controlled item.  d. The process established for user access and privileges.  e. Institutional IT Security measures necessary to secure controlled items for  he PLD team follows established processes for revision control. If none exist, then they work  with their line organization to establish revision control. The PLD team, in conjunction with the  project, if necessary, determines the minimum document and design file types to be  controlled. A set of revision controlled items typically includes the following:   a. Design environment (e.g. *.ADB file for MicroSemi devices).  b. Design and test files.  c. Deliverables.  At a minimum, any time the design team programs the design into a physical device, it also puts  the controlled items into the revision control system. It is best practice to keep all files used in  design, simulation and hardware testing under revision control. This is especially useful in  diagnosing problems where the design needs to revert to a prior test configuration.   he revision control goal for the design environment is to ensure that the design environment is  documented, controlled, and reproducible. These revision control items include the following:  . Setup, project files and any other file that can dictate the behavior of the design tool.  c. Script files and makefiles.  a. Design tools such as those used for simulation, synthesis, PnR, and PLD  programming. If the design is not text- or HDL-based, such as Matlab or schematic, keep the  design entry tool under revision control.     a. Design documents (design specifications, the verification plan, test procedures, etc.).  b. Files needed for producing the design.  c. Internal or external IP that is used for the design.  d. Simulation test benches and environment.  APPROVED FOR PUBLIC RELEASE\u2014DISTRIBUTION IS UNLIMITED                  e. Models used in simulation.  f. Test software and test scripts used during PLD hardware testing.  g. Information obtained from reviews (e.g., peer reviews, action items, defects found, etc.).  h. All results from verification efforts including test results. Any known or open issues   i. All programming files (fuse files, bit files, etc.).  j. Bug reports.  It is a best practice to adopt one of the common software revision control tools (e.g., Concurrent  Versions System (CVS) or Subversion (SVN)) to manage the files. In addition to keeping the  test software and scripts under revision control, the design team records the script, software, and  hardware version information in the test log and archives it along with the test artifacts. The  design team reconstructs the test environment when troubleshooting a problem using these items.  he development plan also defines how the delivered design is uniquely identified within the  version control system. This includes the identifying files used for programming the design, the  programmed device, and information about when to use the programmed device in a higher  assembly. Section 10 contains a list of delivery items.       a. Digital design (basic design, I/O standard, I/O thresholds, etc.).  b. Design capture (VHDL, Verilog, etc.).  c. Design analysis (worst-case analysis, signal integrity analysis, etc.).  d. Radiation effects.  e. Design tools (synthesis, PnR, etc.).  f. Verification (simulation techniques, test techniques, etc.).  g. CM tools or revision control tools.                  The PLD team lead creates and maintains the schedule for the PLD life cycle, which includes,  but is not limited to:           . Upon approval, the schedule is baselined with an initial cost estimate.  g. Deliverables.  h. Training.  i. Monitor progress against schedule periodically.  j.  k. Revise schedule as problems are discovered or new requirements added.   ugs are errors in the design or implementation. \u201cBug tracking\u201d tools simplify the process of  capturing and tracking bugs and the exact logic and test case versions required to recreate them.  This tool is useful for tracking project-level metrics related to defects found versus defects fixed.  It is a best practice for the PLD development team to have a tool for tracking bugs, issues, or  potential design changes. Bug tracking information can include:   a. A description of the error, issue, and/or potential design change.  b. The PLD version.  c. The severity of the error, issue and/or potential design change.  d. The status of the error or issue (open, resolved, in progress, use as is).  e. The test configuration.  f. The individual assigned to resolve the error or issue, or to implement the design change.  g. The required completion date/release date.             A best practice for bug tracking is to select a tool that is searchable, sortable, and provides  statistics for a number of open, resolved items. For larger projects, this simplifies the gathering  of metrics and the sorting of large quantities of issues.   identifies the expected deliverable(s) for this unique development. If there are intermediate  developmental deliveries, they are identified and documented in the development plan.   appropriate stakeholders that can participate for each review. For purposes of this document, a  broad range of possible reviews and participants is provided. The reviews will be customized  per the complexity of the design.   The reviews ensure that the design meets all of its requirements for its intended application early  in the development process to prevent costly debug and rework. Benefits of reviews include the  following:  a. The identification of issues.  b. The clarification of requirements.  c. The sharing of knowledge (technical knowledge, lessons learned, etc.).  d. The generation and satisfaction of exit criteria prior to proceeding to the next phase.  Reviews listed in table 1, List of Possible Reviews, are internal to the PLD development team  and separate from the project milestone reviews. Depending on the project, the schedule of the  reviews may be planned to coincide with project-level reviews. The reviews and list of involved  participants can be customized based upon the complexity of the design.                     Phase  Planning and Requirements  Possible Reviews  Planning Document(s)                 Possible Participants  Project, Line Management,  Stakeholders, PLD Technical  Development Lead  Project, Stakeholders, PLD  Technical Development Lead  Stakeholders, PLD Technical  Development Lead, Subject  Matter Experts as appropriate.  Stakeholders, PLD Technical  Development Lead, Subject  Matter Experts as appropriate.  Stakeholders, PLD Technical  Development Lead, Subject  Matter Experts as appropriate.  Stakeholders, PLD Design Team,  Subject Matter Experts as  appropriate.  PLD Design Team, subject  matter experts  PLD Design Team, subject  matter experts  PLD Design Team, subject  matter experts  Stakeholders, PLD Technical  Development Lead, Verification  Lead  Stakeholders, PLD Technical  Development Lead, Verification  Lead  Depending on the focus of the review, some review checklists can have more details than others  can. Appendix B contains sample checklists.                       equirements are allocated to each electronic assembly and flowed down to the board and  ultimately the PLD. PLD requirements are negotiated between the board design lead and the  technical development lead. The requirements development process iterates as needed. Analyze  and review allocated requirements during each iteration. Any issues and questions that are found  are discussed and resolved. As a result of this review and discussion, the allocated requirements  are refined, clarified, and new requirements derived as needed. For complex PLD designs with  many requirements, tracking such requirements can be aided by using a formal requirements  database tool such as the Dynamic Object-Oriented Requirements System (DOORS).     The technical development lead generates a PLD requirements document, to capture all the  requirements that flowed down. The technical development lead also provides requirements  traceability and derived requirements. Once baselined, this document provides traceability for  the implementation, and establishes the guidelines for the test and verification steps. Most PLD  requirements flow down from the board-level requirements, and can include:           For safety-critical requirements, a unique identification can be used. The identification will be  used by SMA to identify the appropriate level of verification for the requirements that are safety  critical.                 tracing, such as change impact analysis, verifies that requirements are implemented, and assesses  the impact of a system-level requirement change. Bottom-up tracing, such as defect impact  analysis, ensures that only required features are present and assesses the impact on the higher  level system of any defect found at a low level.      a. Analyze the requirements change to determine schedule and cost impacts.  b. In the event of a conflict, assemble the appropriate people to work the issue until   c. Analyze the requirements change for technical impact.  d. Analyze the requirements change for risk impact, including safety.   redundancy, interlocks, upset rates, etc. Appendix E contains additional design considerations.  For safety-critical designs, use design criteria 5 found in table 5, PLD Classification, of  Appendix C.     he verification lead generates the verification plan for verification activities, which includes  methods, environments, and criteria. The verification plan documents the plan to verify that the  design meets all requirements, is subject to the review of the project team, and includes details  regarding how the verification team will record, address, and track to closure the results of  verification activities. Verification occurs to the lowest level possible. PLD design verification  typically comprises simulations and testing in a hardware environment. Under the formal list of  verification methods, simulation falls under analysis.  ndependent verification is recommended for larger and more complex projects or safety-critical  applications, because it supports a more objective interpretation of the requirements. The  advantage here is a more complete assessment of the design.                   (1) Inspection.  (2) Analysis (e.g., simulation, etc.).  (3) Demonstration.  (4) Test (preferred verification method).   including test bench descriptions; identification of additional verification, such as  negative testing or simulations).     (1) Test identifier.  (2) Requirements addressed by the test case.  (3) Prerequisite conditions.  (4) Test input.  (5) Instructions for conducting procedure.  (6) Expected test results, assumptions, and constraints.  (7) Criteria for evaluating results.  (8) Requirements traceability.  (9) Identification of test configuration.  he use of IP cores (acquired, inherited, reused) does not eliminate the need to verify the core.  See section 6.3 for more information on the use of IP. Considerations for the verification of IP  cores include:   application notes, revision notes, test benches, addendums or errata notices for core  modifications, updates, license agreement, and any vendor documentation describing the extent  of vendor verification of their IP cores.                     maximize coverage of functional or operational scenarios and configuration (e.g., \u201ctest as you  fly,\u201d \u201cfly as you test\u201d).   design. In other words, verify that the IP core can be synthesized to incorporate any necessary  radiation-mitigation strategies, such as triple mode redundancy (TMR) or, for the case of a hard  core, comes implemented with appropriate radiation-mitigation strategies.    it is possible to verify some tools, it is costly. A more effective method to mitigate the risk is  through extensive PLD verification using accepted industry-standard tools. It is a best practice  for the designer to read all errata that came with the tools and be part of the user community so  that errors/workarounds can be mitigated/used early.   all the requirements. The matrix shows how the requirements are described/designed in the  design specification and where in the verification plan the requirements are tested. Finally, it  traces the requirements into the verification documentation (test procedure, test bench, analysis  report, etc.) that identifies how the requirement is verified. Table 2, Sample Verification Matrix,  below shows an example.         Method  (I,A,D,T)  T   Test Procedure/  Test Bench/  Analysis Report  TPR-123    Verification  Plan            of the design. For small projects, the design team may combine the preliminary design in the  DDP. For these projects, the system-level design, the subsystem design, and the assembly design  may incorporate the preliminary design.    he PDP is the design phase that begins the design cycle. The top-level design is generated in  the PDP. With the design of the top level, the items from the planning phase can be updated and  changes identified. The PDP can be entered when the following criteria are met:    a. Development plan is baselined.  b. PLD requirements are written, but may not be baselined.  This list does not include all elements of the planning phase. It allows for work to proceed while  additional planning is in progress.      a. A board-level block diagram depicting PLD internal and external interfaces.  b. A top-level block diagram of the PLD architecture.  c. Data flow diagram(s).  d. Selected PLDs part type(s) with preliminary utilization estimates.  e. A clock distribution description with frequency information.  f. A reset distribution description.  g. Radiation effects mitigations (e.g., scrubbing, TMR, etc.).  h. Board-level considerations (e.g., signal integrity, power integrity, power consumption, etc.).  i. A description of all hardware and software interfaces.  j. Re-configurability requirements (if applicable).  If the PLD interfaces to elements outside the board then the design team includes a system-level  block diagram.                 he interface definition, defines the interface between multiple interfaces (e.g., multiple pieces  of hardware, hardware and software, avionics and software, etc.). This document need not be  unique to the PLD. It can be part of a larger document.    The preliminary version of the interface specification is prepared, reviewed, and baselined. The  interface specification can include the following items:  a. The register interface.  b. Bit definitions of registers.  c. All interface signals.  d. Memory map.  e. Protocols (e.g., RS-422, PCI, 1553, etc.).  f. Pinout.  ach development organization documents the approach to meeting certification requirements  for any computing system\u2019s hardware elements that include any off-the-shelf (OTS) components  (e.g., a previously designed \u201cheritage\u201d circuit board assembly, an application-specific integrated  circuit (ASIC) used in another design, IP procured or obtained from another source.)  ach developer of PLDs that include non-development items (i.e., design elements that are  reused from another application or that are procured or obtained from a source outside their  developmental control, such as IP) ensures that the inclusion of such non-development items  meets all the requirements of the PLD design in its intended application. This assessment  extends to the overall circuit design as well.  hen purchasing IP, the licensing agreements are reviewed to make sure they extend through  the life of the project. This includes the maintenance phase. Additionally, purchased IP may not  include the source code or the detailed core design, possibly making testing of the core very  difficult. When the source code is not available, the project has to analyze the risk of using that  core. The core will have to be verified without the ability to review the source code completely.  There may also be limited access to testing the core. The project team weighs the risk versus the  benefits of that core.    When purchasing IP, allow your Center\u2019s legal team to review the licensing agreement.  Licensing agreement negotiations can be lengthy, impacting the schedule. Also, ensure that the  agreement extends through the life of the project, including the maintenance phase.               The PDP is the first phase of the design cycle. The PDP is complete when the following criteria  have been met:  a. The preliminary design is complete.  b. A preliminary version of the design specification is baselined.  c. The interface definition(s) are baselined.  d. A list of proposed IP (heritage and new) that will be used in the design is identified.  e. Reviews are completed as defined in the development plan.  f. The planning phase documents (see section 5) are baselined, including:  (1) Requirements.  (2) Development plan.  (3) Verification plan.  he DDP is entered upon completion of the PDP. The DDP generates the design specification,  but not the design files used to implement the PLD. Detailed design information, such as timing  diagrams, detailed block diagrams, is developed during this design phase. The information  developed in this phase is used for capturing the design during the design implementation phase.       a. The preliminary design specification is baselined.  b. The interface definition is baselined.  c. The PDP and associated reviews are successfully completed.  d. The planning phase documents (see section 5) are baselined, including :  (1) Requirements.  (2) Development plan.  (3) Verification plan.                   t is recommended that the PLD team utilize a common HDL coding style. Design organizations  may consider the use of common coding standards across multiple projects, in order to facilitate  effective reviews and design insight.     a. Standard coding style.  b. Documentation that is consistent with the design.  c. Current, regularly updated documents.  d. Use of appropriate comments for the design.  e. Use of configuration control for the design.   a. Use of naming conventions to allow recognition of the function of signals by their name.  b. Use of the header of the HDL design to capture nomenclature (see Appendix A).  c. Use of modular design to ease testability, readability, and simulation.  d. Use of editor tools (tool editor software, Ultra-Edit, use of spaces versus tabs, etc.).  e. Use of self-checking/documenting test-benches.  f. Use of proper code documentation, particularly inline documentation, which later   g. Documentation of each procedure or function.  h. Use of inline comments to explain thoroughly the applicability of assumptions and                        t is recommended as a best design practice to use synchronous design methods. The behavior of  a synchronous design is predictable/deterministic and more tolerant to race conditions, hazards  (dynamic or static), or glitches introduced by environmental conditions. Fully synchronous  designs can also be more easily migrated or reused across PLD device types. The use of non-  synchronous design methods is rarely appropriate, and their use has to be sufficiently justified,  because they usually require more effort to validate or verify in the design.    a. Transition all signals on the clock edge.  b. Avoid using a gated clock (a clock that is driven from logic, not a clock buffer).  c. Handle carefully signals that cross clock domains. There are many techniques, such  as double registers; metastable resistant registers; first in, first outs (FIFOs); etc. The design  identifies the best method for the particular implementation.  d. Synchronize asynchronous inputs to system clock in one location.  e. Minimize the number of clock domains.  f. Utilize synchronously de-asserted rests.   buffers on clock and reset nets. Use of low-skew clock buffers simplifies timing analysis and  avoids race conditions (e.g., hold-time violations) by enabling more simultaneous (synchronized)  clock arrival times. This ensures more deterministic functional behavior. Therefore, when  sequentially adjacent registers are clocked on a common edge, use low-skew clock resources. It  is acceptable to design with routed clocks, and this can often result in a reduction of power  consumption or an effective increase in the number of clocks available. However, precise skew-  tolerant design techniques and analysis have to be used. In addition, routing clock signals over  long distances inside the PLD to the inputs of clock buffers using regular routing resources may  make the signals vulnerable to crosstalk from nearby signals, possibly resulting in errant  behavior. To avoid this, ensure that PLD clock input pin or logic that generates the clock is close  to clock buffer input.   any analysis tools are useful for analyzing logic within a single chip, but few are effective at  analyzing system or chip-to-chip timing. In addition, while the worst-case behavior of the clock-  to-out of the source chip is easily analyzed using \u201cminimum\u201d or \u201cbest case\u201d timing parameters,  the hold time of the destination chip may need to be analyzed assuming a slow path for the clock  and a fast path for the data for the same calculation. A strategy to consider would be to assign or  allocate delays to each signal leaving one device and being received at the next. These            allocations can be used as constraints for synthesis and timing analysis to ensure that the system  will meet timing once integrated.  In general, rigorous analysis of the chip-to-chip interface delays and clock skew is performed to  validate the destination capture scheme. Analysis considerations include the following:  a. Trace delays from board-level connections (or other medium connectors).  b. Output (source chip) and input (destination chip) buffer delays.  c. Delays from input buffer routing to internal structures.  d. Clock tree latency.  e. Signal skew.  f. I/O signal integrity (e.g., transmission line effects, ground bounce, and cross talk).          verify that the DLL/PLL starts up, stabilizes, and locks up properly and reliably to ensure safe  circuit operation.  upset (SEU). This can result in a change of programming of the DLL or PLL, which is  sometimes subtle, or a change in mode.    (2) An SEU or single event transient (SET) can cause the DLL or PLL to unlock or  glitch and, consequently, make the entire circuit that is within the clock tree  unstable or inoperable, necessitating a reset.  . Account of DLL/PLL clock jitter and stability.  e. Power supply and decoupling strategies on the circuit board for the DLL/PLL circuit.                 Use of internal DLL/PLL PLD circuitry has to include careful analysis of a project\u2019s radiation  requirements and available radiation test data on the PLD\u2019s DLL/PLL circuitry, which is  typically softer than the other elements within the PLD.  PGA designs with multiple clock domains are now common. Perform clock domain crossing  (CDC) analysis. Based on analysis of the clock trees, identify all signals crossing clock domains  and determine the need for metastable state resolution. When de-metastability logic is used, it  needs to be evaluated for its correctness and effectiveness. This is especially important for reset  signals used in each clock domain to ensure proper operation for all possible sequences of reset  removal between clock domains. Additionally, ensure that the latency involved in signal  synchronization is tolerable to the system.     onsider duty cycle in timing analysis for designs that use both clock edges. With justification,  document any designs that pass data from one edge of a clock to the other. Analyze such circuits  using the worst-case duty cycle for each phase. Often designers assume a 50 percent duty cycle,  which may not be the case. Sources of duty cycle distortion include oscillator characteristics,  with 50 +/- 10 percent duty cycles being common, including uneven delays through logic gates  and buffers, etc. Unless required to meet timing, avoid using opposite-edge clocking as it  complicates the timing analysis for the design.   Ensure that proper synchronizers are used for each asynchronous signal to guard against  metastability. Often designers will use two series D-flip-flops (DFFs). While this is a common  and acceptable topology, be aware that for high-speed signals, the failure rate of this  synchronizer can be non-negligible. Analysis has to be done for situations that may require a  third DFF to be put in the series. The following are notable conditions to address:    b. Ensure that there is margin in these circuits as they are impractical to test and verify.  c. Also, note that for ASICs, different flip-flop macros may have significantly different               best practice is to avoid the use of latches because they complicate the timing analysis of a  design. Furthermore, PnR tools do not satisfactorily analyze timing paths with latches. It is not  uncommon that a latch can be replaced in a design by a DFF. Therefore, the recommended  approach is to replace latches with DFFs.    atches can also be unintentionally inferred (added by the tool during synthesis), for example by  not defining all output states. Run a register report after PnR to confirm that there are no latches  present.  FSMs have to be designed with care for critical applications. Verify the implementation at levels  of abstraction appropriate for each circuit. For example, for certain critical sections of an HDL-  based design, examination of the tool-generated netlist via a schematic viewer may be required  to ensure that a reliable circuit has been implemented. There are very few designs with a single  independent state machine. Most designs have several, if not many, interconnected state  machines. Any correction or recovery algorithm (an FPGA or card-level reset, for example)  would need to take into account all of the interconnected state machines and be thoroughly  analyzed and tested in order to verify proper recovery. Note that the correction method may  even reside at a higher level such as at the subsystem or box level.    intended. The analysis also needs to include, especially for critical state machines,  considerations for off-nominal events that could cause faults that interrupt nominal state  transitions. Credible faults could occur because of such hazard events as a disturbance on the  power bus, an electrostatic discharge (ESD) event, a radiation-induced upset, etc. Note that  hazard events are not synchronized to the system clock and the logic network is not guaranteed  to be glitch free.  ny critical state machine has to be robust under all credible faults. In general, analysis of the  combinational circuits that implement the next-state logic and their inputs to the registers making  up the state register is needed. In particular, for any of these schemes, it has to be determined  whether the circuit implementations are static hazard free and, if not, whether an erroneous  transition to a state (or set of states) can occur. It may be very difficult for a user to guarantee  deterministic behavior of the state machine if an upset occurs. This could also be the case for  very large or complex state machines.            The PLD design team addresses FSM lockup at a higher level and analyzes FSM outputs. In  general, each FSM is analyzed to make sure that the system can detect a locked up FSM and  return it to a known state in a timely and safe manner. Recovery options can include an  automated system recovery or an external event (watchdog reset, commanded reset, or power  cycling), if acceptable to the system design. For mission-critical applications, the FSM outputs  have external protection, such as requiring flight software to \u201carm\u201d the FSM outputs.  Implementation of a reset from an external resource (e.g., watchdog timer) can simplify fault  recovery analysis in that the reset forces the entire design associated with that reset into a known  state. Though the externally generated reset would be the preferred approach, if there were no  system-level watchdog available or it does not adequately address an FSM\u2019s response to a fault,  an alternative method could be to implement an onboard watchdog that operates off separate  clock and reset resources.   further recommendation would be to incorporate off-nominal events into the simulation  environment to assess system response, such as verifying a watchdog reset. This assessment  may be extremely valuable given that this functionality may be impossible to test in a hardware  test environment.       practice. The choice of state vector encoding is one that factors in radiation effects, timing  constraints, and criticality of operation. Often, designers allow the synthesis tool to choose the  encoding scheme that is optimal for timing constraints. However, the designer still reviews the  synthesis tool\u2019s choice factoring in radiation effects and criticality of operation. Following are  some factors to consider:  a. In PLDs, if using TMR with triplicated registers, upsets are more common from SETs  than SEUs. Therefore, combinatorial logic poses a greater vulnerability. One-hot encoding uses  more flip-flops, but less combinatorial logic to encode the states and becomes a robust high-  speed option.   decodes all bits in the state, the implementation can recover from an invalid state. However,  when one-hot encoded state machines experience an upset, it is likely that two state bits will  become \u201chot\u201d and activate two parts of the design that aren\u2019t normally activated simultaneously.  The designer determines whether this situation could cause any damage.                   lock up if the FSM interfaces with external logic. In this situation, an SEU could disrupt the  normal sequence of operation.  with error detection and recovery (safing) implemented. As such, avoid over-engineering FSMs.  More specifically, don\u2019t assume that \u201csafing\u201d FSMs individually is better than using one hot  and/or binary FSM encodings without safing. Whether to safe an FSM or not depends on the  system level consequences of an FSM being upset and what recovery actions are needed.      a. Recognized state machines.  b. Lockup states.  dditionally, some logic synthesis tools generate \u201csafe\u201d state machines. Use of this feature is  not recommended because it typically increases the use of combinatorial logic, which increases  the SET susceptibility. If this feature is used, examine the generated design carefully as it could  sometimes add an excessive number of gates to the implementation. Other times, resets are  generated on the opposite edge of the clock resulting in tight timing for the removal of clears that  are not visible to the designer. Note that when using enumerated states in VHDL, not all  physical states are covered (only enumerated states are covered). Hence, the \u201cothers\u201d clause  only refers to states in the enumerated type and not the physical realization. The HDL does not  identify one-hot or binary or gray-coded implementation or which registers have been replicated.  This is not detectable at the black box simulation level or by Boolean equations for logical  equivalence.  c. Outputs from the state machine that can glitch.  d. Unintended register replication.  e. Implementation of the desired and specified style (sometimes the synthesis tool    \u201csyn_preserve\u201d (from Synplicity) can be used to ensure that the synthesis tool does not change  the state encoding.             t is important to understand the purpose of reset implementations. For example, different  approaches are recommended depending on if the reset signal is used to initialize finite state  machines as opposed to protecting external resources (e.g., contention on a tri-state bus,  electrically erasable programmable read-only memory (EEPROM) protection, relay activation,  pyrotechnic initiation).    Failure to reset all registers in a design can cause mismatches between simulation and actual  device. Each flip-flop has either an asynchronous preset or a reset signal. If the flip-flop needs  both a reset and preset condition, one has to be changed to a synchronous signal. If they are both  asynchronous, they can nullify each other since the timing relationship between them is  undetermined. It is important to make sure that the design specification clearly defines all  register states at POR for bits that are directly controlling circuit functions (on- or off-chip)  without first being initialized by software.   PLD is concerned but require board, box and/or system analysis to determine if indeterminate  PLD outputs are acceptable until the synchronous reset is clocked through. Synchronous reset  signals have to be routed on low-skew global routing networks. This is vitally important to  ensure that all synchronous elements in a design are reset at exactly the same time. System reset  is typically active low at the board level because at power on, the board starts at 0 volts so  nothing needs to be done to assert the reset. Inside the PLD, the active state of the reset (high or  low) is dependent on the technology being used. It is best to check the device technology prior  to setting the reset active state. A recommended system reset is asynchronously asserted, and  synchronously de-asserted, with the minimum pulse width required. An analysis is done to  determine the time that the reset is to be asserted and de-asserted. This is design dependent, and  is done for the following reasons:  a. Ensures that the PLD is held in reset at power up even if the clock is not stable.  b. Ensures that the PLD cannot come out of reset in the absence of a clock.  c. Ensures that the internal reset signal is held for a sufficient amount of time to  propagate throughout the chip. This does not allow a glitch on the reset line to cause an internal  race condition.                It is recommended that the team implement synchronous de-asserted reset using a global buffer,  if available. For asynchronous presets and clears, there are two basic parameters that have to be  met. First, there is a pulse width requirement that has to be guaranteed. Second, removing the  preset or clear from a device asynchronously to the clock may result in metastable states in the  sequential circuit. This parameter is frequently called the removal time (asynchronous (clear and  preset) or removal time) and is denoted as tREM. Unfortunately, many data sheets do not specify  the removal time. Use a synchronously de-asserted reset to ensure that the removal time  requirement is met.   rawing a tree of all the reset sources, buffers, and domains is often helpful in ensuring that the  reset logic is well defined. Often there are multiple forms of reset from system resets, software  resets, watchdog timers, etc., and having a detailed tree diagram shows the relationships between  them. Ensure that proper synchronization is made when required. Additionally, if the reset  needs to be activated quickly, the tree helps to ensure that the logic and delays are well  understood. Examples include when there is a need to protect non-volatile memories from false  writes, or other circuits from initiating one-time events, such as firing pyrotechnics or explosives.  he PLD designer reviews/analyzes each I/O\u2019s dynamic and static characteristics, such as  timing, logic threshold, direct current (DC) voltage characteristics, and I/O standard, with the  board designer to take into account the manufacturer\u2019s recommendations to ensure proper  operation of the devices.   dhere to the vendor\u2019s recommendations for handling SSOs. There may be limits to the number  of output pins that can switch at one time. Sometimes the manufacturer specifies these limits in  a data sheet, describes them in an application note, and/or leaves them to the discretion of the  designer. Ground/VDD bounce can be a serious issue that can dynamically affect input switching  thresholds, decrease system noise margins for fast-switching devices with large pin counts, and  lower noise margins. It is also important to note that for many devices, the number of SSOs can  affect the propagation delay time (TPD).  Care and planning is also important for pin assignments. Pin assignments that seem organized  with all the data bits on a bus lined up in a row have been notorious for causing both ground  bounce problems on the printed circuit board (PCB) and routing problems inside PLDs.  Consider using power integrity tools, as they provide a means to accurately predict the effects of  SSOs on a given design. Note the considerations that follow for simultaneous switching outputs,  noise immunity, quiet design principles, and minimizing bounce issues:              together. Refer to the device datasheet for recommendations on allowable SSO signaling per  ground pin.          ground bounce (i.e., high frequency switching pins, pins with fast (short) rise times and  address/data buses).   . Driving test data through the Joint Test Action Group (JTAG) test interface,  especially over multiple parts, can induce SSO data patterns, particularly with large data buses.  For example, switching patterns from FFFFFFFF to 00000000. Though this may be an artificial  failure or an artifact of the test, this can damage or potentially overstress hardware through a loss  of control.   voltage I/O standards available. Lower voltage I/Os have lower transient currents that can  reduce SSO.   interference (EMI) tests, presents different conditions for normal bench testing or systems  application. Design for the worst-case over the entire project flow.             usually has more on-chip resources, and can operate at higher speed than the one-time  programmable PLD. The issue with using reconfigurable PLD in space flight or high altitude  vehicles (e.g., High Altitude Long Endurance (HALE)) is its susceptibility to radiation-induced  errors. As a result, additional logic is usually needed to reduce such susceptibility and improve  the device reliability for space applications.   to perform the required logic functions. The internal configuration memory is not always  radiation hardened and can be upset by radiation events. When the configuration memory is  altered through a radiation event, the impacted logic can be permanently changed unless the PLD  configuration memory is reloaded or scrubbed. The upset rate of configuration memory depends  on the PLD technology and the radiation environment.   he simplest form of protection used on PLD configuration memory is open-loop scrubbing.  This consists of using a separate radiation hardened or tolerant device to continuously overwrite  the configuration memory of the PLD with configuration data from a known and reliable source.  This method of protection is easy to implement and can usually correct the upset memory very  quickly. However, its effectiveness depends on the radiation upset rate of the PLD configuration  port. It only works if the PLD configuration port stays healthy. Without a feedback mechanism,  it can sometimes be difficult to determine whether the configuration port is receiving the data  sent by the scrubbing logic. As a result, this method of protecting PLD configuration memory is  usually used along with other protection schemes, such as configuration memory read back or  periodic reconfiguration of the entire PLD.  nother technique is to read back and verify the configuration memory. The content of the  memory can be verified by either comparing it to that from a reliable source or checking the  associated cyclic redundancy check (CRC) signature against the expected value. Once the  configuration memory is deemed corrupted, it can be overwritten with data from the reliable  source. The correction can be done only for the corrupted memory blocks or all the  configuration memory blocks, depending how sophisticated the readback/scrubbing controller  design is. Unlike the scrubbing logic, the readback logic can be implemented inside the  reconfigurable PLD itself as long as the health of the readback logic can be monitored by an  external radiation hardened or tolerant circuit or PLD. This method of configuration memory  protection is more reliable than open-loop scrubbing. Any corruption to the configuration data  or the configuration port can always be detected. The drawback with this approach is that  response time can be slow. Once the corruption is detected, another mechanism, such as open-  loop scrubbing or full reconfiguration, has to be deployed to correct the problem. This is  expected to take more time than using open-loop scrubbing.           TMR is also used for mitigating radiation induced upsets in PLDs. The scheme employs three  copies of the circuit to be protected by TMR and a voting logic. The correct output of the circuit  is determined using majority rule. Feedback logic is sometimes used to correct the errors in the  corrupted copy of the circuit. For reconfigurable PLDs, TMR is usually not built into the PLD.  The designer may need to implement TMR or other methods to mitigate the potential problems  caused by radiation-induced upsets.  Designers need to be aware that there are different TMR methods including Local TMR, Global  TMR, and Distributed TMR. Each has its advantages and disadvantages in terms of protection  afforded versus impacts on device or circuit resource. It is not sufficient to rely solely on  manufacturer\u2019s literature on radiation effects mitigation. For the purposes of this document, it is  recommended that the PLD designer (or design team representative) also consult appropriate  radiation effects engineering resources to determine the optimum method for the intended  application.  TMR can be implemented manually by the designer or by using design tools. Once TMR is  implemented, the designer ensures that the PLD synthesis tool does not reduce the redundant  circuits from the TMR design while optimizing the design.  n-flight reconfiguration is used very carefully if the PLD is performing system-critical  functions. Improperly configured PLD can cause the device to stop functioning in-flight.  Systems designed to support in-flight PLD reconfiguration have to have a fail-safe mode to  restore the system to the last working state in the event of a reconfiguration error. The fail-safe  mode allows the PLD to be reconfigured using the last known reliable configuration file stored  locally in the system, from an external location on the spacecraft, or even from the ground.    onsider adding signals to facilitate design development and debugging. Debugging designs in  the lab comes with many constraints. One of them is visibility of signals. Be sure to allocate test  points or spare pins for diagnostic purposes. There are many steps that a designer can take to  address these constraints, including the examples that follow:   internal signals. Such interfaces can come in very handy, but often come with frequency  limitations and limit the number of signals that can be viewed simultaneously. Be sure to  accommodate the PLD signals associated with the JTAG interface.  . Debug mux. A multitude of internal signals can be brought to a multiplexer whose  output connects to PLD outputs. The multiplexer select signals can be driven by PLD inputs or  by other suitable means. This approach can be used when a PLD\u2019s JTAG interface has  limitations that pose a problem.              c. Heartbeat output. A quick and easy method of checking if a PLD is \u201cfunctional\u201d is to  generate a heartbeat output signal that pulses periodically when certain critical events occur. The  utility of such a signal depends greatly on how the designer chooses to generate the output.    analyzed sufficiently in the final flight design to ensure no impact on in-flight system  functionality or reliability. Ideally, all testability features are disabled for flight.  uring the DDP, detailed design information is generated based on the preliminary design.  Detailed timing, state, and block diagrams are generated. The PLD specification containing the  detailed design is prepared, reviewed, and released. The specification contains enough details to  allow an engineer to implement and verify the design. Updates to the specification include the  following:    a. Block diagram of the PLD architecture, including:  (1) Clock generation, distribution, frequencies, etc.  (2) Reset generation, distribution, etc.  (3) State machines, state diagrams, and state tables.  b. A functional description of the device and a detailed description of the individual  blocks, including IP definition and usage. The mathematical functions that are required will  include the following:  (1) Method of calculation, including the name of the theorem (e.g., whose method of  a fast Fourier transform or which Reed Solomon implementation is being used).  (2) Precision.  (3) Accuracy.  (4) Performance.   . Software interface, including:  APPROVED FOR PUBLIC RELEASE\u2014DISTRIBUTION IS UNLIMITED  . SEU mitigation implementation, including scrubbing, TMR, etc.  e. A description of all interfaces, including board-level implementation constraints  (critical pins for board routing, proximity to other devices, input slew-rate limitations, etc.).                Draw a board level diagram showing the clock trees for the circuit that includes PLLs, DLLs,  clock buffers, clock dividers, and all chips that use the clock. See the example provided by  figure 3, Sample Clock Tree Diagram, that follows.      (1) Memory map.  (2) Register definitions.  (3) Operations constraints.                n order for a PLD to operate correctly, it is important to review and ensure the correctness of the  interface between the PLD and the board on which it resides. The following list provides some  key areas to review for the PLD and board interface:     VPUMP, and VREF for PLDs from MicroSemi and HSWSPEN, INIT_B and PROB_B for  PLDs from Xilinx all have to be terminated properly for the PLD to operate correctly. Review  the PLD datasheet for the requirements about how the special pins are connected, and verify that  the corresponding connections are correct on the board.       cold-sparing and power sequencing requirements are met. Review circuitry that may be powered  independently of the PLD, including cold-sparing applications, and make sure that adequate  protection circuitry is implemented.   undershoots do not violate PLD manufacturer\u2019s absolute maximum ratings for I/O signals.  Using low slew rate for the PLD outputs and terminating the board signals are two effective  methods for reducing ringing levels for board level signals.   board. Make sure that the selections for the pull-ups and pull-downs inside the PLDs are  consistent with those implemented on the circuit board.                        verification process need to be tested. The purpose is to mitigate any risks that may develop as a  result of functions that may not be fully tested during requirements verification.     processing units (CPUs), graphics processing units (GPUs), and/or digital signal processors.  These embedded processors execute software ranging from a simple series of instructions to an  operating system running applications, which is separately developed from the PLD design code.  This Handbook does not cover the development, verification, and validation of software for such  embedded processors. All software will be covered by software requirements in NPR 7150.2,  NASA Software Requirements.         a. The design specification is reviewed and baselined.  b. The interface definition(s) are baselined.  c. The detailed design (from the design specification) is completed.  d. Reviews are completed as defined in the development plan.  he design implementation phase is the phase when the design is implemented, coded, and  reviewed. This occurs after the detailed design is completed. The generated result will be the  PLD programming file(s) that will be used in the verification aspect. During the design  implementation phase, the verification team may begin to implement preliminary versions of the  verification items. These can include test procedures, test scripts, test benches, etc. In addition  to generation of the programming files, the design undergoes several timing analyses, including  STA and worst-case timing analysis.                    a. Transferring the design from the design specification to the HDL code (coding).  b. Incremental testing: Simulations at both the module and chip levels.  c. Reviewing the design files.  The sections of this phase are not followed in linear form. These phases are iterated by the  designer and the team, as appropriate.   specification, the coding standard, and the design standard and implements the design in the  specified technique (VHDL, Verilog, schematic entry, etc.). The designer follows the coding  standard setup by the project and applicable sections of the design standard (section 8.4).     of simulation) to test the operation of the code. Incremental tests begin at the lowest level and  continue up through various levels of code. For purchased IP, it is best first to perform a test on  the IP to confirm its functionality prior to using it in the design.  implementation (code, drawings, etc.) per the development plan. For example, the purpose of a  code review is not just to check the stylistic portions of the code, but to ensure that the design is  complete and meets the requirements specified. Issues found at the design file level are much  easier and take fewer resources to fix than those found in various stages of verification.  Prior to any review, the design is deposited in the appropriate revision control system.    he verification team begins development of the test preparation (test benches, test scripts, test  procedures) used for verification and independent testing of the device. This effort can occur in  parallel to the development of the design. Section 9 defines the verification items.                             such as:  A. Flip-flops without sets or clears, indicating circuitry that will not be reset on         B. Flip-flops with both sets and clears, indicating possible asynchronous design  techniques (the absence of set/clear flip-flops does not indicate the absence of  asynchronous design techniques).     rising edge design) that could place constraints on clock symmetry and be  more difficult to analyze with the STA tool.                                e. Timing analysis in the synthesis phase can be used as an indication of long timing  paths and of predicted timing. However, accurate timing analysis can only be achieved from a  STA that is performed after PnR.   the source and destination clock domains have not been replicated. Replicated flip-flops in  synchronizers can result in intermittent functional failures. Synthesis constraints are added to  these flip-flops to prevent replications and preserve the structural design of each synchronizer.             A. Package.  B. Speed grade.   A. Military range is suggested to ensure sufficient timing margin.  B. The tools assume that temperature is the device junction temperature and not    (4) Radiation level.  (5) Device-specific settings.    (2) Verify I/O compatibility with the board designer.  (3) It is preferred to accomplish this with a vendor-specific constraints or   d. Run PnR.  APPROVED FOR PUBLIC RELEASE\u2014DISTRIBUTION IS UNLIMITED                                 (2) Check maximum timing with procured speed grade.  (3) Check minimum timing using the fastest speed grade, in case the PLD vendor   (4) Include delays to/from pads on the board.  (5) Consider clock source and delays.  (6) Include loading on outputs.  (7) Get min/max data for any device interfacing with the PLD.  (8) Analyze both best case and worst case timing to reveal any setup/hold time   (9) A minimum 10 percent timing margin is suggested.  (10) Carefully scrutinize logic crossing clock domains, and the symmetry    properly through all environmental conditions it may experience. PLD timing requirements are  derived from all of the PLD\u2019s interface components to ensure timing compatibility. Constraints  are applied as needed to the synthesis and/or PnR software to meet all timing requirements.    timing and functionality are both met.  8.4.2 Timing Analysis                 a. Temperature.  b. Voltage.  c. Radiation \u2013 total ionizing dose (TID).  d. Process (speed grade, best/worst).  e. Aging.  PLD vendors try to provide timing estimates, which are based on user-specified environmental  values or ranges, that envelope the effects of all of these factors. The effects of some factors  (such as radiation and aging) are harder to predict than others. Therefore, positive timing  margins (margin on top of margin), such as 20 percent at initial PnR and 10 percent for the final,  are preferred. For example, prolonged radiation exposure can slow down some circuit elements  and/or speed up others within the same device. In addition, logic upsets due to transient  radiation events are addressed, but not as part of timing analyses.  Timing analyses may need to be run with more than one set of environmental conditions and  resolved into an overall set of minimum and maximum values that envelope the values from  various environmental conditions. The number of environmental condition combinations  analyzed is often referred to as the number of corners analyzed. An example of a two-corner  analysis is shown in the table 3, Example of Two-Corner Analysis, below.  Table 3\u2014Example of Two-Corner Analysis  125 \u00b0C  3.0V and 1.35V 3.6V and 1.65V  100 krads  STD  0 krads  -1  Best/Min  -55 \u00b0C  Condition  Worst/Max \n Temperature  Voltage  Radiation  Process (speed grade)  Process (best/worst) Worst  Best              The types of timing analyses needed depend on the functional types of inputs, outputs and  internally generated signals in the PLD. The types of timing analyses are as follows:  a. Clock frequency.  b. Reset pulse widths.  c. Asynchronous input pulse widths.  d. Synchronizer metastability settling time.  e. Synchronous input setup and hold times.  f. Combinatorial input pulse widths.  g. Synchronous output delays.  h. Combinatorial output delays.  i. Clock domain crossings.  Typically, several types of timing analyses are needed to show that a PLD design will perform  properly. For example, a PLD design with a peripheral component interconnect (PCI) interface  would need clock frequency, synchronous input setup and hold times, and synchronous clock-to-  output timing analyses to show compliance to PCI interface timing requirements.   TA software is used to calculate the maximum clock frequency for each clock domain that uses  dedicated, skew-safe clock circuitry. This is typically the first timing check designers perform to  see if their design implementation works at the required clock frequency(ies). Specify a  frequency for each clock domain in the PLD to constrain the PnR software so that the required  frequency(ies) is achieved. Specifying frequency constraints enables the STA software to report  pass/fail status.  or clock domains that pass signals between both edges of the clock, account for duty cycle  variations. Note that rising versus falling edge delay differences inside the PLD contribute to  duty cycle variations.  f the maximum clock frequency reported by the STA software is not fast enough, review the  slowest paths and consider using a faster speed grade PLD, redesigning the logic and/or  determining if multi-cycle clock constraints can be applied. Slow paths sometimes consist of  signals that functionally have two or more clocks cycles to settle. For these paths, consider  adding multi-cycle timing constraints.  void clock domains that do not use dedicated skew-safe clock circuitry because using them  may require more manual effort (analysis and/or structural design modifications) to preclude  internal setup and hold timing violations.                esets that assert and negate asynchronously to the PLD\u2019s clock domain(s), such as power-on  resets, are often synchronized before being distributed throughout the PLD. Resets are often  asynchronously asserted and synchronously negated, so that all sequential elements are  initialized as soon as possible but released from reset on the same clock event. Analyze  synchronized resets, as well as synchronously generated resets, like synchronous inputs to  sequential elements even though these drive the asynchronous inputs. This will sufficiently  negate the synchronized reset before the next clock event so that all sequential elements come  out of reset together.     nalyze asynchronous inputs that synchronize to clock domains inside the PLD to ensure the  minimum low and high pulse widths needed by the synchronizing circuit(s) in the routed PLD  are less than the minimum low and high pulse widths of the input.   The minimum low and high pulse width of a \u201cstandard\u201d two flip-flip synchronizer (shift register)  is not just its clock period. The minimum low and high pulse width is the sum of the flip-flip\u2019s  clock period, setup time and hold time and the rise versus fall time variances of the input\u2019s path  to the first flip-flop.   lip-flops used to capture asynchronous signals may have longer clock-to-output settling times  when setup or hold times are violated due to metastability settling in the flip-flop. Although it is  possible to have a flip-flop\u2019s output oscillate indefinitely due to metastability, it is unlikely the  feedback paths in the flip-flop will be perfectly matched to sustain this.  synchronized on every clock edge. It may be better to design and analyze these as gated  synchronous inputs.    he typical synchronizing circuit consists of two or three flip-flops connected as a shift register.  For each synchronizer, ensure the path from the first flip-flop to the second has sufficient timing  margin (slack) to account for metastability settling. Having margin is typically not an issue if  there is no combinatorial logic between these flip-flops and these flip-flops are usually placed  close together. It may be worth adding a maximum path delay constraint for each synchronizer  from the first flip-flop to the second that is less than the clock period to help ensure margin for  metastability settling.                   TA software can be used to calculate the minimum setup and hold times needed for each  synchronous input pin. Setup and hold constraints can be specified to guide the PnR software  and enable the STA software to report pass/fail status.   setup and hold timing on every clock edge. For these types of inputs, it may be worthwhile to  constrain the setup and/or hold times to values larger than the clock period, as appropriate. This  is analogous to multi-cycle timing constraints.    nalyze combinatorial inputs used to drive outputs without being clocked to ensure the rise  versus fall time variances through the combinatorial logic do not exceed the input\u2019s minimum  pulse widths. Otherwise the input pulse could be missed and not reach the output or significantly  distort the output pulse shape. This could cause glitches that produce unwanted outputs. It is  recommended that outputs be clocked.    or designs where the output delay relative to the clock matters, STA software can be used to  calculate the minimum and maximum clock-to-output delays. Minimum and maximum clock-to-  output delay constraints can be specified to guide the place-and-route software and enable the  STA software to report pass/fail status.     or designs where the output delay relative to its input(s) matters, STA software is used to  calculate the minimum and maximum input to output delays. Constraints for minimum and  maximum input to output delays are specified to guide the PnR software and enable the STA  software to report pass/fail status.                       The timing analysis shows that each CDC works properly and includes dispositions for each  signal involved in the CDC. The clock domains have either fixed or (more often) varying clock  edge timing relationships.  ynchronous CDCs may be able to take advantage of guaranteed timing relationships between  the source and destination clock domains and use STA to verify setup and hold times for their  control signals.  Asynchronous CDCs have to work with all timing relationships (leading, lagging and co-  incident) between the source and destination clock edges. Asynchronous CDC control signals  are analyzed using asynchronous pulse width timing analysis.  Setup and hold timing analysis are used for the data signals of CDCs. More specifically, the  analysis shows that data presented on the appropriate source clock edge meets the setup and hold  times needed by the appropriate destination clock edge. CDCs may be designed to hold data for  multiple clocks before and/or after control signal transitions to facilitate meeting these setup and  hold times.    esign is baselined in the appropriate configuration control system. This includes design source  files, simulation test benches, script files used during simulation, synthesis, and PnR. The goal is  to keep everything required for design implementation and verification under configuration  control so that the design can be reliably reproduced.  his phase includes generating the PLD design per the design. The design may not be the  complete design but may be the completed section(s) per the plan. It includes the process to  synthesize, PnR, and generate the programming files for the design.    a. Design implemented in HDL is baselined.  b. Simulations are completed.  c. Reviews per the development plan are completed.             files(s) to ensure that versions of all source files and tools are identified. If required, it can serve  as an as-run procedure. In addition, the procedure can contain SMA witness or acceptance. The  procedure serves as a standard method to generate the programming file(s) that maintain a  detailed list of what source files are used. By tracking the versions of the source files, changes  and modifications are easily tracked through revision control. The procedure may contain the  following information:                  mplementing the design is the process by which the build (or implementation) procedure is used  to generate the programming file(s) that are required. A separate build procedure is used for  each PLD that is generated. When implementing the design, the design files are first to be  placed in the appropriate CM system. The procedure is then run with the appropriate level of  SMA required by the project. The resulting programming files are then put in the appropriate  revision control repository.                a. The design implementation is complete.  b. Reviews are completed as defined in the development plan:            (1) Timing Constraints.  (2) Synthesis.  (3) PnR.  (4) Timing Analysis.  (5) Programming File.  meets the specified requirements. Verification is generally a formal process in which  verifications are monitored by QA as they are being performed. See section 5 for a description  of verification planning.  he verification begins with a discussion of the test process and test procedures. Test procedures  have to be completed prior to verification, but are described here because they logically fall into  the verification phase.                       b. A successful build of the device is maintained under version control.  c. A programming procedure is baselined.           test procedure is a document that delineates the test steps required to verify full compliance of  the PLD implementation to the requirements. It is to be written clearly, so that it can be handed  to an independent tester. The test procedure may include topics such as:  . Requirements addressed by the test case.  c. Test configuration(s) (recorded information about the test setup, such as software       . Test input (things required as input to the test, e.g., test scripts).  f. Instructions for conducting the test.  g. Assumptions, constraints, and expected test results, including pass/fail criteria for      test of the programmable device is witnessed or monitored by QA personnel, in accordance with  the project documentation.                    monitor the activities, filling the role normally filled by QA for flight projects.  Any discrepancies encountered are handled according to the project error tracking process.  Section 10.1 describes the programming test procedure in detail.     board. The amount of testing required is dependent on the functionality. Simulation for  verification may not always be appropriate. For example, the simulation of the digital interface  of an analog-to-digital (A/D) converter does not verify the operation of the A/D converter. The  verification of the A/D conversion circuit can only take place on the hardware. However, it is  advantageous to simulate the operation to ensure that the appropriate signals are operating as  expected.    a. Off-nominal operation.  b. Hardware failures.  c. Basic command operation.  d. Internal operation of the PLD.  hen using simulation for formal verification, a self-checking test bench is the best method.  The test bench that is used for formal verification is reviewed during the review process. The  test bench review is set up to ensure appropriate operation and requirements verification.  It is a best practice to simulate all functionality of the PLD prior to running on the actual  hardware even if formal verification is not gained.       a. Assign a test number to the test cases for tracking purposes.  b. Use self-checking/documenting test benches.  c. Analyze code coverage of simulation and test vectors.                    d. Automate tests using scripts for repeatability and unattended runs.  e. Place test bench components under revision control.       a. Electrically EEPROM flash memory.  b. 1553 chip.  c. Memory.  d. PCI.   a. Timing from device data sheets (setup and hold checking).  b. Handshake protocols.  c. Error checking.  d. Fault injection.  It is a best practice to obtain models from the vendor so that the appropriate delays are correct.  Some simulation tools come with models. Check with the tool vendor for their models.                     a. Waveforms for sanity check.  b. I/O waveform/timing with the board design lead or other PLD designers as       (1) Understand why they are there.  (2) Document any decision to ignore them.  the simulation cases. Code coverage analysis is performed for statement coverage, toggle  coverage, branch coverage, and expression coverage. All of these coverage analyses can  uncover deficiencies in the design simulation. Coverage analysis is used frequently while  implementing the design to assess the completeness of the simulation test benches.   Simulation code coverage analysis provides a useful measure on the thoroughness of the  simulation test benches. A design is only released after it has been thoroughly simulated.  Though it is desirable to have a high simulation coverage, setting up a hard coverage requirement  is not practical. Achieving high simulation coverage can sometimes be very laborious and time  consuming and not be supported by the project schedule.    Instead of imposing requirements on the code coverage level, the designers disposition all the  coverage deficiencies flagged by the code coverage tool. Reviewing coverage deficiencies helps  the designer understand the cause of the deficiencies and determine how they need to be  addressed. In the disposition, the designer documents the rationale for the coverage deficiency  and risk associated with not addressing this deficiency. The dispositions are released along with  the coverage report as part of the final EIDP of the PLD design. The disposition for the coverage  deficiencies and the coverage report provide a metric for the quality of the design simulation.  They are treated as part of the design documentation and released along with the design.   timing delay models extracted for the worst-case and best-case operating conditions. The  designer bases the design simulated during the back-annotated simulation on the final HDL net  list produced by the PnR tool and models of the logic primitives specific to the targeted PLD  device. The back-annotated simulation is performed using maximum, typical, and minimum              timing models. PLD design is verified with back-annotated simulation before each formal  release. By running a post PnR structural simulation with unit delay (without the timing  information), the designer can verify that the design is accurate. The value of a unit delay post  PnR structural simulation is that it may execute significantly faster.  assing the back-annotated simulation proves that the design is not altered by the synthesis and  PnR process. It also validates the timing constraints used during the synthesis and PnR process  when the back-annotated simulation is performed using the best and worst timing delay models.   to re-run every test in back-annotated mode. The designer needs to decide which parts of the  simulation need to be re-run using back-annotated design.   f a failure occurs during testing, the designer investigates the failure. This investigation needs  to include root-cause determination, which is necessary to ensure that a proposed solution  resolves the failure. The designer may need to generate a new PLD version and perform  regression testing. The amount of regression testing depends on the level of functionality where  the failure occurred. Automated, self-checking test benches will help simplify regression testing.  The verification plan clearly defines the details and corrective actions of test failures.    The designer may initiate replacement or reprogramming of a device due to a test failure. The  designer will establish a new design baseline prior to programming a configuration-controlled  device with a new design. Section 10.1 discusses programming practices.  ndependent verification is an approach used to provide higher confidence in the outcome of the  verification process, by avoiding the inadvertent masking of design errors that can sometimes  occur if the same personnel are responsible for both design and the design verification. A classic  example is the misinterpretation of a requirement: If both are designed, tested, and analyzed by  the same person with the same misinterpretation, the design can pass the verification, but still not  meet the requirement. The use of independent personnel for verification is highly recommended  in cases where sufficient personnel, cost, and schedule are available. There is additional  overhead for maintaining separate personnel for design and verification that may be prohibitive  for some projects; however, without this measure, those projects will have to decide whether to  accept an increased risk.  s with all verification activities, independent verification can occur at any point throughout the  life cycle, including simulation, analysis, developmental tests (e.g., \u201cbreadboard,\u201d \u201cengineering  model,\u201d etc.), or integration tests with software or higher level systems. The design team may           also utilize independent verification for items such as IP or other non-developmental items used  as part of their design approach.  n those cases where the outcome of independent verification is a required step in the developer\u2019s  process, the design team has to identify those constraints early in the development to allow for  adequate planning and schedule.   he verification team verifies the design team\u2019s work products from all phases of the life cycle  against the same set of requirements used by the design team. In order for an independent team  to begin verification, they have to use the same set of requirements used by the design team. In  addition, the verification team has to have access to all the design products (e.g., HDL, constraint  files, etc.), as well as documentation from the design team, including traceability reports, full  descriptions of any derived requirements, or design features that were incorporated. For testing,  the independent team generates test cases and procedures per the verification plan and verifies  the functionality based on the requirements.  primarily as a way to begin to understand how the design operates but also generates its own test  benches to use.           ommunication between the design and verification teams is of paramount importance for  independent peer verification. The term \u201cindependent\u201d is not to be interpreted as a ban to  communication, including (where appropriate) direct contact and discussion about the design,  and any verification issues found. A successful outcome is achieved through a thorough  understanding of the work of each team.  Traditionally, design activities and independent verification activities could be divided into  separate phases, where the design team handed off the design to the verification team, and then a  verification report was provided back to the design team. The design team could then address  any required changes and iterate through the verification team until all issues were resolved. In           owever, a more iterative model utilizes ongoing development (including correction of issues  previously found by verification) concurrently with verification activities. Verification activities  can span multiple iterations of the design cycle that leads ultimately to the final product. This  can result in multiple versions, with differing issues, and different iterations of changes. In this  scenario, communication is of even greater importance. Ultimately, both the design and  verification teams have to converge upon one final design supported by successful verification  results.  this scenario, written documentation, such as design and version description documents and  verification reports (see section 9.5), are the primary formal means of communication.   \u201cbug tracker\u201d tool (usually electronic) is one valuable way of achieving communication  between the design and verification teams, particularly in cases where the two activities are  active in parallel. The bug tracker provides not only communication, but assists in traceability of  changes, and development of the Version Description Document (VDD). See section 5.2.8 for  additional information about bug tracker tools.  he developer and/or an independent party, as defined in the development plan, can perform the  verification review. The verification process ensures that the PLD meets all the requirements for  development and design of the project.           a. Overall success/failure evaluation of the verification.  b. Any known deficiencies, limitations, or constraints.  c. Any results of any corrective actions that were assigned during the verification process.  d. Impacts of any items listed.  e. Verification environment including impacts.  f. Verification results:  (1) Project unique identifier of test and procedure.  (2) Details of results with traceability.           (3) Problems/anomalies encountered.  (4) Deviations from test cases.   (1) Date and time of the verification.  (2) Verification environment, hardware and software configuration.  (3) Identification of individuals who performed the verification.  A verification report does not necessarily mean a separate document. The report can be an as-run  test procedure, provided the team records all pertinent information in the test procedure.  regression plan is to be developed that will indicate what testing needs to occur as changes are  made. A basic form of a regression plan can be a regression matrix, as seen in table 4,  Regression Testing, below.   Function 1  Function 2  Function 3    Test Procedure 2  X  X  Test Bench 1  X      t is desirable to have the test environment for hardware verification resemble the final  configuration to achieve a higher level of confidence in the test results. This can include the use  of hardware emulators, simulation software, flight hardware, qualification hardware, certification  hardware, certification software, and flight software.  evices used for the final deliverable article are preferred for the final verification of a PLD  design. For cases in which the final deliverable is a one-time programmable PLD and there are  budget and schedule constraints, verification may be performed on a prototype device prior to  the final deliverable. In these cases, it is recommended that the prototype device closely  resemble the final part.  n addition to the choice of prototyping devices, it is also important to perform hardware  verification using high fidelity test interfaces and stimuli. If simulators produce the test stimuli,                                 hen the PLD design contains a software interface, it is recommended that the PLD be tested  with the final software, such as the flight software. Though test software is sometimes sufficient  for verifying the PLD software interface, it typically does not operate the PLD the same way as  the final software. Test results obtained using test software have lower fidelity than those from  testing using the final software.  it is important to have the behavior of the simulator verified against the final interfaces and  document any non-compliance.       a. All as-run test procedures and test reports are released.  b. All review documents are released.  c. All documents that have changed are released.  d. EIDP is released.  e. Anomalies are documented and dispositioned.  f. All requirements for this release are verified             board or assembly level testing. Delivery of the device requires that related design  documentation and data products be completed and released under CM control. This includes,  but is not limited to, items identified as follows:     design or to recreate the design when needed. Following is a list of as-built design files  released when the design is delivered:             (6) Synthesis Transcript/Log File: Includes the synthesis transcript/log file for the as-  built design. Additional documentation is provided for the disposition of all the  synthesis warnings.  7) PnR Project and Script Files: Includes all the design database and binary files  produced during the PnR process. The goal is to have all the files necessary to  regenerate the fuse/configuration/programming file when needed.   9) PnR Transcript/Log File: Includes the PnR transcript/log file generated for the as-  built design. Additional documentation is included for the disposition of the PnR  warnings.                     (10) PLD Programming File: The \u201cfuse/configuration/programming\u201d file for the design.  Necessary precautions are required to preserve the integrity of the programming file  when transferring the programming file from one computer platform to another.  11) Design Review Reports: Includes review reports for all design reviews held for the  delivered design and evidence supporting the closure of the action items from those  reviews.  12) PLD Design Drawing: The drawing that documents the PLD vendor information,  PLD vendor part number, tool used for developing the design (including licensing  information), and the revision and/or the last modification date of all the files listed  above. All the design files referenced in this drawing are released under this  drawing number as supporting documents.                   In addition to the above files and documents, the team also releases a drawing or equivalent  documentation along with the design to document how to label the programmed device and how  it can be clearly linked to its source design files.                      programming and, when required, post-programming, test procedure is developed for each  design. The design team can capture the programming procedure in a document or in an altered  item drawing (AID). As a minimum, the procedure contains the following information:       installing the device into the programming hardware, loading the design files into the  programmer, configuring the programmer for the specific device, ensuring appropriate ESD,  programming the device, etc.   . Verify the expected checksum against that reported by the programmer based on the  fuse information loaded from the programming file. Verify the expected checksum against that  reported by the programmer based on the fuse information read back from the programmed  device.                     Once programmed, a PLD becomes an application-specific part. The manufacturer\u2019s part  number no longer identifies it. The design team assigns a unique identifier or a project part  number to the programmed device. Typically, instructions for programming and marking a  programmed PLD are captured in a design specific AID and the drawing number, serial number,  and revision information for the AID becomes the part number marked on the programmed PLD.   products required by the EIDP, such as the design source files, synthesis, and PnR transcripts,  and, most importantly, the programming files. In addition, the team also releases an AID or  equivalent document to link the EIDP revision information and design specific information, such  as fuse checksum or design date code, to the marking or part number of the programmed device.  t is very helpful if the PLD is designed with a software readable identifier or label. This is  usually implemented by storing the identifier or label, including the design revision information,  in a software accessible register. When such an implementation exists, it is also important to  document software accessible identification in the AID or equivalent document.   LD maintenance considerations are different depending on the design\u2019s place in its life cycle.  This section describes designs as either active or retired. The determination of the category of a  design is based on the life cycle plan developed by the delivering organization. The rules used to  make this determination are based on factors like the delivering organization\u2019s lifetime guarantee  on the design and whether an active project is currently using the design.  t is recommended that the delivering organization establish a design library (revision control or  CM) to store designs. Maintaining an active design in the library is a job focused on protecting  the pedigree of the design from the modifications performed by projects. The delivering  organization is responsible for ensuring that the design has been verified with the appropriate  level of rigor before submitting the design to the library.  t is recommended that projects refrain from inheriting designs directly from each other and  instead go through the design library. This ensures that the organization can play its role in  protecting the pedigree of the design. Direct project-to-project inheritance of designs bypasses  this important role of the organization.   The delivering organization is typically not able to make design changes without project funding.  Therefore, track the desired design changes with designs in the library. They can be  implemented and verified when project funding becomes available and the new revision of the  design can be accepted back into the library.           ctive designs are those that the organization has released under configuration control and used  on active projects. Other projects have to be able to retrieve the design from a library under CM  and immediately put to use. This includes the following:   a. Its specification is kept up to date.  b. Problems reported against the design have been documented.  c. Its tool chain is maintained in working order.  anomalies and changes to the requirements. When this occurs, there are two options: Fix the  anomaly, or use the design as-is. Fixing an anomaly may be the preferred solution. However,  the complexity associated with making a change involves a risk trade.    Making a change to a design reintroduces that design into the design process and sets it back to  an appropriate design phase. The design modification has to progress through the same  processes with the same rigor until a new final design can be delivered to the customer. Along  with the design process, the project team considers schedule and budget effects.  esign problems considered to be use-as-is are documented as a design idiosyncrasy in the  appropriate level of documentation. Capturing the idiosyncrasy preserves intent behind the  design and provides a path for product improvement. At a minimum, the design specification is  updated to document the as-built behavior and the idiosyncrasy is clearly identified.    for active designs no longer apply, but the organization keeps all retired designs available for  reference and study. As part of the life cycle plan, it defines a format for storage of these  designs. The selected format focuses on longevity because designs may be stored for a very long  time. When a design is originally released as active, a copy of the design in this designated  format has to accompany it. This way, as the design ages and is considered retired, the design  knowledge is stored in an electronic format which is backed-up.                  he intermediate or engineering releases are interim releases that add functionality or correct  issues. As the intermediate releases are saved, an active note of the changes with rationale for  the changes are documented and maintained. Other items in the notes include issues found and  testing completed. This allows multiple developers/users to understand the changes and a single  developer to remember why the changes were made. The version number increases each time  the release is changed and checked back into the revision control tool. A developer may group  multiple changes into an intermediate release. Note: Some engineering releases may be used in  preliminary hardware/software integration (HSI) testing. These releases are usually  accompanied with the VDD or drawing.  he final release is the release provided to the customer or stakeholder as the final product. This  release has completed verification as defined in the development plan and is accompanied with a  released EIDP.     his section provides guidelines aimed at ensuring the quality of PLD designs from out-of-house  contracts and procurements. These guidelines can be customized based on the criticality or class  of the mission, complexity of the application, or maturity of the design (new, minor  modifications, re-use).   . The vendor provides NASA insight into the PLD design, development, and test  activities, including monitoring verification adequacy; trade study data; auditing the PLD design  and development process; and participation in PLD reviews and technical interchange meetings.                     1. Issue contract requirements for vendors to deliver a PLD development plan that describes  the vendor\u2019s process for developing flight PLD applications, and deliver the PLD design  data packages for each PLD, which contains all the required data elements to perform an  independent review of the design.    2. Review and acceptance of the vendor\u2019s submitted PLD development plan.  3. Participate in agreed-to reviews to assess vendor\u2019s compliance to the approved PLD   4. Review and acceptance of the PLD design data.  5. Continue review and assessment of flight PLDs throughout the integration and test               his initial step is to ensure that all vendors providing hardware for the instruments and  spacecraft are contractually obligated to deliver a PLD development plan (see section 5.2)  describing the vendor\u2019s methodologies for developing flight PLD solutions, and the complete set  of artifacts that allow for an independent review of all flight PLD projects developed by the  vendor. These two sets of requirements are depicted in the subsections that follow.                    The PLD design data package includes the same information defined in section 10. The PLD  design data package has to contain all source code and design files indicated in section 10. Be  sure that purchased IP licensing agreements allow NASA to view all source code, have access to  all design files, and remain valid during the entire maintenance cycle.     everal iterations may be required until the final version of the vendor\u2019s PLD development plan  is accepted by NASA. It is also possible that the plan is modified over the lifetime of the project  to adjust to the reality of the system development. Every modification of the plan requires  formal acceptance by NASA.   n accordance with the vendor process described in the approved PLD development plan, NASA  representatives may participate in peer review meetings. The PLD reviewer representing NASA  is expected to receive the review materials (presentations, requirements, specifications, test  descriptions, source code, etc.) at least a week before the scheduled date of the meeting. The  reviewer reads all the material in preparation for the meeting. After the meeting, the reviewer  prepares a summary report for the flight project management as a record of his/her participation  in the meeting.  he PLD reviewer fulfills two roles in the peer review meetings. First, the reviewer provides  expertise to support the review team in assessing the state of the project, making suggestions for  corrections and/or improvements. Second, the reviewer assesses whether the vendor is following  the process described in the approved PLD development plan.  t a point(s) established in the approved PLD development plan, the vendor supplies NASA  with a PLD design data package. For simple revisions to PLDs, one review may be sufficient  after PnR, timing analysis, and signal integrity analysis have been completed. Typically, a  minimum of two reviews are warranted, one concurrent with the beginning of non-flight testing  and one prior to commitment of the final design.              The vendor reviews and assesses all NASA PLD design findings and recommendations. The  vendor notifies NASA of those instances where corrective action was not taken on specific PLD  design findings and recommendations.  t is recommended that the reviewer utilize a PLD design checklist to perform the analysis of the  design (one suggestion is included in Appendix B). The checklist can also be provided to the  vendors as a guide for them to prepare their designs for independent review.  he independent review is complete when all findings have been dispositioned/resolved or, if  not, risks are identified and bounded. The reviewer submits a report to the appropriate flight  project manager with all the responses to any findings and notifications and the final version of  the checklist with comments and responses.  n alternative method to independently review a PLD design data package is to assemble an  independent review board at the vendor\u2019s facility. A PLD subject matter expert chosen by the  flight project leads the review board. The vendor provides the complete PLD design data  package the least two weeks prior to the review board meeting.    the review board meeting. At the meeting, concerns and recommendations are discussed and  action items are assigned. The lead reviewer is responsible for taking action items and follow-up  on their resolution.  recommendations. The vendor notifies NASA of those instances where they decided not to take  corrective action on specific PLD design findings and recommendations.   A PLD subject matter expert chosen by the project performs an independent assessment of the  vendor submitted PLD design data.  The work of the independent review board is complete when the lead reviewer is satisfied with  the submitted design and submits a report to the project.   phases, be it at the board, box, instrument or spacecraft levels. The PLD review team  participates in delta reviews to resolve all technical problems.              SUGGESTED SOURCE CODE  HEADER AND FOOTER TEMPLATE  //***************************************************************************  // File Name:  //  // PLD Name:  //  // Project Name:  //  // HDL Standard:  //  //  // THE TECHNICAL DATA IN THIS DOCUMENT IS (OR IS NOT) CONTROLLED UNDER THE U.S.  // EXPORT REGULATIONS, RELEASE TO FOREIGN PERSONS MAY REQUIRE AN  // EXPORT AUTHORIZATION.  //  //  // Notes:  // This section includes what the module is intended to do and other  // related design information  //  // Change log is located at the end of the file  //  //***************************************************************************   //***************************************************************************  //  // Change Log:  //  // Date: mm/dd/yy Name: FirstName LastName  //  // Description:  // Use \u201cCreated\u201d for \u201cDescription\u201d for the initial release.  // The name field includes first name and last name.  //  //  // Date: mm/dd/yy Name: FirstName LastName  //  // Description:  // Describe the changed made for the next revision  //  //  //***************************************************************************             is expected to change over time. In order to avoid changing the line number of the code, it is  recommended to include the change log in the footer.              A PLD design checklist is a helpful tool to assist both the designer and subsequent reviewers.  The checklist can be used during the design process to ensure all aspects are covered that can  then be reviewed during design reviews. A sample design checklist follows. The files that may  be needed in the design reviews are as follows:  a. PLD design specification.  b. PLD verification matrix.  c. Synthesis script/project file.  d. Synthesis constraints file.  e. Preliminary synthesis log/transcript file.  f. PnR script/project file/database file(s).  g. PnR constraints file.  h. PnR log/transcript file.  i. Worst-case timing analysis report.  j. Fuse or bit file.  k. Design source files.  l. Test bench files.  m. Board schematic drawing and net list.  n. Data sheet for components connected directly to the PLD.  o. Other script files used during design, simulation, synthesis, and PnR.  p. Action item status summary from earlier reviews (gating and peer reviews).  q. A readme file describing the simulation environment and setup to help reviewers              Is the design specification using required  format? If not, list the deficiencies.  In order to facilitate the review process, it is  desirable to have a template for the design  specification.   Is the design specification complete?  Does it have sufficient details for design  implementation and verification? If not,  identify the deficiencies.   Check the design specification against  the board schematic/netlist. List I/Os  with internal and external pullups.  Identify all the I/O standards used in this  design. Are the internal and external  terminations compatible? Do the pin  assignments agree? Is the correct I/O  standard used for the intended use?  The design specification is complete enough to  start a code walk-through. The peer review is  delayed if the design specification is deemed  immature. The design specification provides  sufficient information about the design to allow  the peer review reviewer to perform an  effective review of the HDL source code.  Need to double check the interfaces between  the PLD and the board. Need to ensure that the  physical requirements, such as I/O standard,  pin assignment and I/O type, imposed by the  board designs, are met.                     The code is to be well commented to make it  readable and inheritable by others. See  Appendix A for recommended header/trailer  template.  Review Item  Does each design module have required  header/trailer (when applicable)?  Is the design, HDL source code (or  equivalent) well commented?  an one understand the flow of the  design using only the comments?  s there an International Traffic in Arms  Regulations (ITAR) warning included in  all source files, if it is required on the  project?  Is the HDL code (or equivalent) easy to  follow? Identify improvements for  better readability.  The code has to be readable to the reviewer to  have a meaningful review. The statements  need to be short and concise.  Regardless of the coding style adopted, it is  always easier to follow the code when the style  is consistent. This is also true with signal  names.  Excessive long lines and inconsistent  indentation can make the HDL source difficult  to read.  Is there a consistent coding style in the  source code?  s there a consistent signal naming  convention?  Does the HDL source code contain  excessively long lines?  s there proper indentation in the source  file for readability? Are the indentations  consistent (same number of spaces, no  mixing tabs with spaces)?                              Are there any recommended  coding/implementation optimizations?  The designer can sometimes overlook simple  things. The reviewer can sometimes spot  design optimizations not seen by the designer.  Reasonably optimized code can be reviewed  more easily.                  Is the design matching its specification?  Identify the inconsistencies if there are  any.  The design specification and the design need to  be consistent.  If there are any parameters used for  customizing the design for different design  instances, an autonomous process, such as the  use of scripts, is developed to ensure that the  parameters are set correctly for the targeted  application.  Need to make sure that there is a reliable  process to set up these variables correctly  during the build process.  Does the HDL use any  constants/parameter in the design?   f so, how are they adjusted to ensure the  proper values assigned for a specific  design instance?  requiring adjustments between different  design instances (engineering model  versus flight model)?   Are there any global  definitions/variables, and \u201cifdef\u2019s\u201d in the  source files?  f so, are they set up correctly for the  intended applications?                         Review Item  How many clock domains are there?     clock domains. Need to understand how the  pulsed signals are de-metastabilized when the  signals are going from a fast to a slow clock  domain.  Clocks need to be buffered using global  buffers.     The FSM code is clear enough for review.  FSM outputs need to be registered to avoid  potential glitches caused by state transition.     ow many signals cross clock domains?  Are the signals pulsed or leveled signals?   How are the signals buffered/de-meta-  stabilized, for both signals going from  fast to slow and slow to fast clock  domains?   hen the reset is used in multiple clock  domains, is it de-asserted synchronously  to the clock from the domain?       How many FSMs are in the design?  Can the logic flow in the FSM be  understood easily?                    Need to identify potential lock-up states and  look for undefined states in the FSM. FSM  designs contain a default condition. Need to  ensure that the default conditions are capable  of directing the FSM back to a safe state in the  event of an SEU.  Using vendor/device specific primitives makes  the design less portable.  Are all the states used in the FSMs  defined? Do the default conditions in the  FSM direct the FSM to a valid safe  state?  re there any states polling for status? If  so, is there potential for them to become  lock-up states?  Are there any vendor/device specific  primitives used in the design? If so, why  are they used?  Are the vendor SSO-related  recommendations followed? If not, is  there power integrity analysis data  available to show acceptable noise level  on the ground and power planes?  SSO causes ground bounce and reduce noise  margin. Need to identify these signals in  advance so that proper measure can be taken to  alleviate its impact.     Derived and gated clocks tend to create  asynchronous designs. It is sometimes hard to  weed out timing problems with asynchronous  designs.    Are there any derived or gated clocks?  Are both edges of a clock used in the  circuit? If so to either, how are they  used? Are there any potential timing  issues with the way they are used?    Are there any potential race conditions?  (This is hard to tell without deep design  penetration).  Race conditions cause the design to behave  unpredictably.                         Is there any register using only  synchronous reset? If so, what is risk of  having an undefined state for that  register? For registers driving output  signals, what is done to ensure a  deterministic state for these output  signals if synchronous reset is used?  Need to make sure that the outputs of the PLD  have deterministic state during POR. Using  synchronous reset can create brief uncertain in  the outputs.   Do all the \u201ccase\u201d (or equivalent)  structures have a default state? List all  cases with a default state.  Need to make sure the case structure has all  possible cases covered.   Are there any IP or inherited design  modules in the design? If so, are all  inputs to the top level IP or inherited  modules either connected to a signal  source or terminated? Are all the unused  outputs from the top level IP or inherited  modules left unconnected?  IP or inherited design modules are expected to  have unused functions, inputs and outputs.  Unused inputs at the top level need to be  properly terminated and unused outputs need to  be left unconnected.   Are register clears always using an  explicit action? If not so, described how  they are cleared.  Do not want to clear any registers  inadvertently.                      Too many warnings tend to cover up real  problems.  Need to understand if the design is constrained  adequately. Over or under constraining the  design can lead to unreliable product.  Does the preliminary synthesis report  have warnings?   Review the synthesis and PnR constraint  files.         Are control bits that activate different  functional behavior independently  controllable without knowledge of prior  bit states?    Are all software writeable registers  readable?  Do not want write-only register. Need to be  able to verify the content of register after write  access.   Is there any feed-through network (input  pin tied directly to output pin without  going through any flip-flops)?  Hard to control the timing of feed-through  network.                                 Are there any tool-specific synthesis  directives embedded in the HDL source  code? If so, why are they needed?  Need to understand why the synthesis  directives are used.  Could the design be altered by the  synthesis tool in any way during the  synthesis process?  Need to make sure that the synthesis tool does  not unintentionally change the FSM design,  replicate registers or logic blocks, etc.    Need to review the synthesis directives and  settings. As a minimum, review the following  information:   Device technology.  - Part number.  - Package.  - Speed grade.  - FSM encoding control*.  - FSM optimization control*.  - Resource sharing setting.  - Fan-out limit.   to be TURNED OFF. This allows the design  entered by the designer to stay unaltered during  the synthesis process. In Synplicity, for  example, the symbolic_fsm_compiler has to be  set to zero to preserve the FSM encoding  scheme selected by the designer.   Is the synthesis script/project set up  correctly?                   If \u201cifdef\u201d is used in the source code, is  the synthesis environment set up for the  right \u201cifdef\u201d conditions?  \u201cifdef\u201d can change the as-built design. Need to  make sure the right variables are defined in  synthesis.   What device/package/speed  grade/operating voltages is the project  set up for? Are the parameters correct?  Need to review the PnR directives and settings.  Need to review (when applicable):  - Device family.  - Package type.  - Speed grade.  - Die voltage.  - I/O voltage.                 or MicroSemi, need to review the selection of  the following options (when applicable) for the  fuse file:  Rationale  Need to review the fuse/bit file generation  settings.   Are clamping diodes for unused I/O pins  disabled?  - What programming algorithm is selected?  - Is JTAG reset pull-up resistor used?  - Is the global set fuse used?  - Is Antifuse security feature enabled? (This  feature is not desired.)  parameters for Bitgen:  - Setting for HswapenPin.  - Setting for UnusedPin.  - Is DONE pin driven after completion of  configuration?  - Is PERSIST set if configuration readback is  used?   The environment has to be set up correctly for  the tool to perform the STA correctly. Need to  review set up on:  - Operating temperature range.  - Operating voltage range.    Identify the parameters for fuse/bit file  generation. Are they set up correctly?   What operating environment is the PnR  tool set up for? Is it consistent with the  expected operating environment?                  What are the flip-flop, combinatorial  logic, I/O and timing margins? Are they  adequate?  Need to ensure the design margins are meeting  the requirements defined by the design  organization.   Is the I/O standard and threshold level  consistent with the components shown in  the schematic?  Need to make sure that the signal levels  specified by the PLD are compatible with those  specified by the devices interfacing to the PLD.  For example, is a 5V CMOS output from the  PLD driving a device using 3.3V CMOS I/O?  This might work logically, but can create an  electrical stress condition to the device.                      How are the test cases organized? What  is the fidelity of the simulation models?  Is the test bench organization support  effective verification review?  The design of the test bench affects the  effectiveness of the verification effort. It uses  high fidelity simulation model supplied by  vendor when possible. Constraints of the  simulation models need to be noted in the  verification matrix. The organization of the  simulation tests need to support the  organization of the verification to facilitate the  verification review process.  Are there any complex algorithms in the  design? If so, how are they verified? Is  there any Matlab type simulation done  on the algorithm? If so, what has been  done to reconcile the Matlab simulation  results with the simulation results?  It is sometimes impossible to simulate complex  algorithm adequately in HDL simulation.  However, it is likely to achieve reasonable  confidence level of the design when comparing  the limited HDL simulation results with those  produced with Matlab or other modeling tool.  Are self-derived requirements from the  design specification covered in the  verification?  It is important to make sure that the  verification addresses the self-derived  requirements documented in the design  specification.  What is the maturity of the verification  matrix? Has the verification matrix been  reviewed?  The maturity of the verification matrix can  help gauge the maturity of the design.      What is the code coverage of the existing  simulation test bench?  Uncovered statement, toggle, transition, etc.  need to be dispositioned.                          Need to pay special attention to functions that  can only be tested in simulation.  Review Item  Are there any functions not testable in  hardware?   testability of these functions in  hardware?    Are all the test benches self-checking?  If not, what is done to make sure that the  test results are consistently verified?  Self-checking test benches makes sure that the  simulation results are consistently verified.  Visual inspection of the waveforms does not  always detect unexpected test results.                     Are internal probe points limited to 2  per tile?   Is embedded FIFO controller used in  the design?  Embedded FIFO controller is not used  because it is not rad-hardened in RTAX.   Are single-ended clock inputs only  assigned to the P-side of a P/N clock  input pair?  According toMicroSemi: \u201c\u2026when CLKBUF  (HCLKBUF) is used with a single-ended I/O  standard, it must be tied to the P-pad.\u2026of the  hardware clock (HCLK) package pin. In this  case, the HCLK N-pad can be used for user  signals.\u201d                          This appendix provides a framework to assist projects in the customization process. It uses a  risk-based assessment and safety-criticality factors. This process cannot be applied to safety-  critical or mission-critical projects. The following tables calculate a project classification score  and then use this score to determine applicable parts of this document to the given project.    b. Each item (row) gives a score from 1-5 based on a number of factors.  c. Average the score from table 5 (rounding up).               Single Branch Single Center  Low number  of users  Most staff  experienced  Staff  experienced    Half of staff  experienced  3 Centers  Outside  Center  Few staff  experienced  4+ Centers  External to  NASA  Staff not  experienced   No testing  required  Minimum  testing  Standard  testing  required  Integrated  testing  Major testing  effort required   Commercial  Off The Shelf  (COTS)  Evaluation  Board  Proven  custom  Modified  custom      Familiar to  project  Software has  to be  purchased and  learned  Some  software has  to be  developed  Full custom  software has  to be  developed  Integration of  Deliverables   Some  integration   Highly  integrated  Fully  integrated    Table 5\u2014PLD  ClassificationFactor                                             Well proven,  known to  Center  Proven with  some Center  experience  Proven, but  new to Center  Partially  proven    Projects identified as safety-critical and/or mission-critical uses column 5 for every  row in this table.           Implementation Risk \u2013 An indication of how familiar the team or Center is with this type of  implementation or technology.   Integration of Deliverable \u2013 The PLD is always on a board with some additional circuitry. This  is meant to distinguish the level of integration with other boards, functions, software, etc.           Table 5\u2014PLD  ClassificationFactor                    Table 6\u2014PLD Development Customization Recommendations  4+  2    PLD Development  Plan  Requirements  Bug Tracking  Verification Plan  Planning Review  Requirements  Review  Design  Specification  ICD  Architecture  Review  PDR  Design  Specification  Design Practices  (Section 7.3)  Detailed Design  Review  Design  Specification  Review  Build Procedure  Code Reviews  Revision Control  Design Practices  (Section 8.4)  Synthesis Review  PnR Review  Test Procedures  Verification  Independent Peer  Verification  Verification Review  Programming  Procedure  Revision Control  Formal Release (in  CM)  Documentation  RDD  Delivery Review  Schedule and  Budget  Simple  N/A  N/A  N/A  Schedule and  Budget  Simple  N/A  N/A  N/A    Simple Block  Diagrams  N/A  Simple Block  Diagrams  N/A   Yes  Simple  Yes  Yes                       N/A  Recommended  Basic  N/A  Recommended  Basic   N/A  N/A   N/A  N/A  N/A  Unit Testing  N/A  Unit Testing            Simple Report  N/A  N/A  Simple Report  N/A  N/A  Yes  Yes  Full   Yes  Yes  Yes  Full       Full  Yes  Yes   Yes  Yes  Yes  Yes           Yes  Yes  Full   Yes  Yes  Yes  Full       Full  Yes  Yes                    Informal \u2013 A discussion with colleagues that is not formally documented or  tracked. It could be a tabletop review or informal discussion.                     Table 7, Guidance for PLD Life Cycle Products at Various Reviews, below summarizes the current  guidance for PLD life cycle products and their maturity level at various life cycle reviews. The chart  serves as guidance only. Final decisions are made at the project level.   D  D   SDR  P  P  P  D  P  D  PDR  B  B  B  P  P  P  CDR  U  U  U  B  B  B  TRR  U  U  U  U  U    Product  Development Plan  Schedule  Requirements Specification  Verification Plan  Design Specification  ICD  Test Procedures  Test Reports  \u2022 D \u2013 Draft  \u2022 P \u2013 Preliminary  \u2022 B \u2013 Baselined  \u2022 U \u2013 Updated  \u2022 F \u2013 Final                                                          he following bulleted list provides design considerations (highlighted in bold) that the PLD  requirements document needs to address. The PLD design team considers these items when  creating the requirements and implementing the design. For example, in a safety-critical design,  the design team ensures that a requirement is in the form of: \u201cThe PLD device shall provide the  status of inhibits used to control hazards.\u201d This was taken from the first bullet/design  consideration.     \u2022 Hazardous Function Control. Computing systems provide hazardous function control  where the inadvertent activation, deactivation, or proper control by the function could  result in an identified critical or catastrophic hazard.  \u2022 Safe Initialization. Computing systems are initialized to a known, safe state. Circuitry  interfaced to the PLD takes into consideration the transient nature of inputs/outputs  during power-up/power-down conditions.      \u2022 Off-nominal Power. Safety-critical computing systems establish a safe or powered-  down state when self-monitoring functions detect off-nominal power conditions.       operational time predicted to cause a critical failure, following detection of predetermined  indications of incorrect or incomplete processing.               a. Demonstrate completeness of system state requirements including the following:  (1) Design starts in a known safe state. Interlocks are initialized or checked to be              A. Every state has a behavior (transition) defined for every possible input.  B. Every state has a behavior (transition) defined in case there is no input for a   (2) Non-determinism criterion - the behavior of the state machine is deterministic.  (3) Value and timing assumptions:        machine cancels the sequence automatically, returns to a safe state, and informs  the operator.                    rovide sufficient noise margin, adequate slew rate, and glitch filtering. Transient effects have  to be considered on the reset circuit. For the application of power, the output of the POR or reset  circuit is ideally a solid logic level and glitch-free. This requires the POR circuitry to be  designed using logic elements that operate correctly at the low ramping up voltages seen during  power up. This ensures that the POR signal is valid at the earliest time possible in the power-up-  down sequence of events. Inrush currents to timing capacitors are not to exceed the maximum  for that capacitor type. Rise times to logic gates, if used as a comparator, are not to exceed the  input's specifications. Gates with hysteresis inputs are often used for this purpose. Note that  even with that type of input, output glitches may occur and several stages of logic gates are not  to be used to dampen them. The most robust solutions often utilize a comparator with hysteresis.  worst cases. These often differ substantially from laboratory supplies and may be non-  monotonic or have substantial overshoot and ringing. Note that flight power supplies are often  slew-rate limited to minimize conducted emissions on the power bus. The time constant of the  supply may exceed that of the POR circuit.    the inputs of logic gates are protected. Most CMOS inputs, but not all, have ESD diodes from  the input to the supply rail. Discharging a large capacitance through that input may damage it.   power bus. While many circuits may recover or be recoverable from a power-on reset, this is not  true for all circuits. One such example is non-volatile, erasable memories, which need to be  carefully protected.    The topics in this appendix focus on considerations for the PCB design. They may serve as  discussions but are not necessarily applicable to the PLD design.                 For reset circuits, many implementations have \u201casynchronous application, synchronous removal\u201d  of the reset circuit. However, for many devices, in particular many programmable devices, the  inputs can be blocked or ignored during the power-on transient. This may be because of the need  for charge pumps to start or configurations to be loaded and then released. For devices with  synchronized inputs, the clock oscillators have to start, perhaps taking many tens of milliseconds  (ms), before the reset can be applied. Outputs of these devices are to be handled at the same  system level as the reset, which may appear to work on the schematic or in the HDL design files,  but is ignored by the real circuits. See figure 5, Recommended Power-On Reset Implementation,  that follows.   teady state or DC effects are also important. Check the leakage currents of timing capacitors  and logic gates, as the amount of leakage current times the resistance of the timing resistor may  result in a voltage drop that eliminates all noise margins.    time is sufficient for all circuits in the system in order to avoid premature release of the POR  signal, which may result in an indeterminate state. The following illustrates some factors to  consider when determining start-up time:     circuits having internal power-on reset circuits. The timing of all these resets have to be  analyzed for best- and worst-case behavior.                    . Components, such as PLDs and crystal clock oscillators, may have start-up times that  are a function of the rise time of the power supply. This behavior is often inadequately specified  or not specified at all.   the POR signal has to act as a gate (via external circuitry), blocking false signals during the  power supply rise time transient and then releasing after all circuits are stable. On the other side,  when the power comes down, the POR circuit may need to be asserted early, ensuring that  critical circuits are safe before the logic elements lose control as the voltage drops. Devices that  often need protection are pyrotechnic and explosive initiators, EEPROMs, flash memories, etc.  Note that some devices, such as microcontrollers, have internal flash memories; therefore, it is  recommended that the team evaluate all components and system interfaces for necessary  protection by the POR signals.        For every device, the design team carefully reviews the data sheet and design schematics to  determine whether each special pin is properly terminated. Termination of many of these special  pins cannot be verified by test.  nsure that each configuration pin is carefully checked against the latest data sheet. Some pins  have very high internal pull-up resistors that can be compromised by high-speed signals on the  board level. In addition, some configuration pins can naturally just happen to float to the desired  state with nominal operation observed. Beware of special pins, such as programming pins, that  are required to be terminated appropriately for flight.    to have properly terminated inputs. For normal CMOS devices, this is a requirement. Certain  programmable devices, such as FPGAs, often take care of unused pins via software, exploiting  the programmable nature of the microcircuit. However, the limitations for each pin have to be             thoroughly considered. For example, in MicroSemi SX and SX-S, clock inputs, such as HCLK  or the global routed clocks, do not have an output stage\u2014they are special purpose. They have to  be terminated by the user. Failure to do so can result in large unintended currents that could  cause device damage.  Depending on the device, the manufacturer may reserve pins labeled as \u201cN/C\u201d (no connect) for  internal purposes. Check each pin carefully according to the specification and clarify with the  manufacturer if necessary about the risk involved with terminating them on the board.   any devices have custom test interfaces that have to be handled on a case-by-case basis. Since  they hook up to test equipment, following the manufacturer's instructions is recommended. For  example, MicroSemi SX-S device test pins need to be series terminated.   f PLD I/O are used to implement a debug interface for development, make sure that the inputs  are safely terminated or driven and that outputs are not toggling in the final flight configuration,  causing unnecessary EMI and noise.     nsure that output signals are terminated properly. For single-ended signals, start by using  termination resistor values equal to the trace impedance minus the output impedance of the  driver (Rterm = Ztrace \u2013 Zdriver) then perform signal integrity analysis to optimize the termination  resistor values.    ensure that there is a smooth transition through the threshold. For loaded clocks, perhaps  traveling over long runs, reflections may often result in non-monotonic transitions causing false  or double clocking. Note that this may happen on the \u201cinactive\u201d edge. Similarly, overshoot and  ringing can also cause false clocking, particularly on the transition to ground. Unterminated nets  could result in ringing that is a source of EMI, even when they do not contribute to logic failures.  tight limits on how far outside the rail a signal may travel, sometimes coupled with maximum  time outside of the recommended limits.                required, adding them later could require additional time in layout, debugging, rework, and/or  costly board respin. Measurements can also be used to supplement this effort.   at specific values. Board designers can consider the source termination options of the FPGA,  and design traces accordingly. In addition, input terminations can be considered as well,  especially with Low Voltage Differential Signal (LVDS) terminations or double data rate (DDR)  interfaces.  . Be aware of part-specific default operation. For example, differential interfaces, such  as RS-422 and LVDS standards, require that receivers whose inputs are open, output a logic \u20181\u2019  to the system. Thus, systems need to be designed so that such a logic \u20181\u2019 state does not cause an  unintended lock up of the system.  a. Avoid contention when actively driving tri-state buses. Have a guaranteed off-time  between drivers on the bus in the worst-case. A clock cycle between tri-stating one driver and  enabling another may be sufficient but a thorough timing analysis is necessary. Be sure to  consider timing parameters that have to be added together. For example, the tri-state time of an  external SRAM\u2019s output enable that is controlled by a PLD\u2019s state machine would be the sum of  the time cut off out of the PLD + the travel time on the board + the SRAM\u2019s tri-state time.          . Be sure to consider the power up, reset, or the configuration cycle for the device to  make sure that outputs are not floating or contending. One method to mitigate contention is to  gate FPGA-sourced control signals with board-level POR using discrete CMOS logic gates to  disable tri-state drivers in all devices on the bus.                  t is important to examine input slew rate. Some high-speed devices have very stringent  restrictions on input transition times. Failure to meet the requirements may result in oscillations  (figure 6, Glitches Due to Input Slew Rate Violations), multiple clocking, degradation, or  damage.     may be too slow. Take appropriate precautions if older digital logic families are used that may  have outputs that are not compatible (e.g., too slow) with high-speed devices.   avoided since it may damage components if the switching speeds are not matched, and it can be  difficult or impractical to test this redundant topology. If this needs to be done, consider using  an external buffer or splitting the loads between two or more nets, each driven by a single output.   xamine voltage thresholds, DC compatibility, and noise margins. When mixing devices from  multiple families, even from the same manufacturer, care has to be taken to ensure the devices  are operated within specifications and there is sufficient noise margin. This may be problematic  when substituting parts for either upgrading circuit performance or dealing with obsolescence  issues.  For inputs, many CMOS technology devices advertise \u201ctransistor-transistor logic (TTL)  compatible\u201d inputs. However, these inputs may in fact differ rather significantly from their TTL  counterparts. The first major difference for many but not all devices is the impedance presented  to the interface when power is removed from the device. For example, when radiation-hardened  CMOS latches were substituted for soft 54LS373 latches in the Galileo attitude control            Another related difference is the maximum voltage that can be applied. Some bipolar devices  are useful for reliable level shifting from higher voltages to lower ones; CMOS replacement  devices will forward bias to the protection diodes resulting in unintended current flows and  possible damage or circuit failure. Finally, many CMOS inputs have logic thresholds that are not  truly TTL compatible. That is, the TTL voltage threshold for input high (VIH) specification is  often not met, with VIH (max) values of 2.2V, 2.4V, and sometimes 2.5V being specified  whereas true TTL devices have a threshold defined by two diode drops, typically in the range of  1.2V to 1.4V.  TL outputs are only guaranteed to drive to VOH = 2.4V so there may be little or even negative  noise margins present in these situations. The switching point difference can also lead to circuit  failure, depending on the signal integrity. Often TTL outputs, when switching, exhibit non-  monotonic-behavior in the waveform, particularly with heavy and/or long loads. While the  behavior is often at a high enough voltage so that TTL devices operate correctly, the often higher  VIH of CMOS devices may result in multiple clocking. Pull-up resistors can restore adequate  DC noise margins in these situations if given enough time to settle, which may be quite a while  for this passive circuit. Note, however, that TTL to CMOS clock interfaces designed in this  fashion often fail logically since the CMOS input may see multiple transitions resulting in double  clocking.   It is strongly recommended to check all specifications carefully. For example, many CMOS  devices when driving loads are specified at only very low current levels for high or logic \u20181\u2019  signals. However, TTL inputs take substantial currents and do not present the high impedance  seen by CMOS field effect transistor (FET) inputs and the output may be dragged down. For  output loads that are a mix of CMOS and TTL inputs, they often have to be split to guarantee the  high voltage needed for the CMOS inputs. This is typically 70 percent of VDD, and the high  current needed for TTL inputs, with the lower VIH of 2.0V. Another factor to consider is the  structure of the output stage in the CMOS device. For example, some devices will not swing all  the way to the high rail and are voltage limited. This may result in some totem-pole current if  the p-channel FET in the next input stage is not cut off. Some devices, even with a 5V I/O  supply like an RT54SX series, only drive outputs to the core voltage of 3.3V, making this CMOS  output incompatible with 5V CMOS inputs on the same board.  computer's memory units, block redundancy circuits failed since the sneak path through the  radiation-hardened inputs\u2019 ESD protection diodes was not accounted for when power was  removed.         Components currently have many supply voltages, including 1.5V, 1.8V, 2.5, 3.3V, and 5.0V.  There is also an abundance of I/O standards with the newest devices being programmable, so  their characteristics are not obvious or known from viewing a board schematic. Therefore, I/O  compatibility has to be carefully verified, particularly when substituting \u201cnew and improved\u201d  devices or alternate devices.   savings, care has to be taken when designing a system with blocks that are independently  powered. Many CMOS devices present low impedance when powered down through either the  intrinsic or the ESD protection diodes. Other devices, with cold sparing inputs, may have high  input impedance that is suitable for operation. For PLDs, selecting 3.3V PCI compatibility, as  one example, can result in a \u201ccold sparing\u201d device no longer being high impedance since a  clamping diode is enabled. While many bipolar devices are compatible with cold sparing  architectures, some devices have a sneak path to VCC through the output (figure 7, Sneak Path in  Some LSTTL from Output to VCC) . Be sure to consider test setup, not just the flight  configuration. For example, consider whether a piece of test equipment needs to be powered up  and down co-incidentally with the flight unit.               ollow device family datasheets to ensure proper power-up and -down sequencing. Power  sequencing requirements may differ between flight and prototype devices. Many of the newer  technology devices require two or more power supplies. Often these are divided into supplies to  power the core of a logic device and a second supply to operate the I/O cells. Additional  supplies may be needed for PLLs and DLLs, special I/O standards, or various bias supplies, such  as external charge pumps. The supplies have to meet all of the DC standards as well as ripple  characteristics, particularly for circuits such as PLLs. The sequence that power is supplied to a  single device in certain cases, can affect circuit behavior, performance, and reliability. For  certain devices, such as SX-S series devices, if the I/O supply is brought up before the logic core,  a large inrush current may be present; this would not be the case if the order of the supplies were  reversed. For certain devices, incorrect power sequencing can result in overstress or damage.  Often the requirements for sequencing are in application notes. When parts that require  sequencing are present, they need to be flagged, and the design has to incorporate circuit  protection, as required.  nalyze design for sneak paths between I/O that interfaces powered and unpowered devices.  The power supply sequencing between interfacing ICs, either on the same or separate boards, has  to be considered. Many ICs, particularly CMOS, present a low impedance to the system when  powered off. Most of these ICs require that the power supply be brought up prior to the  application of signals on either the inputs or the outputs (many PLD outputs also have inputs  active in the general purpose I/O modules). Some programmable ICs cannot be analyzed by  inspection of the schematic; the particular I/O configuration has to be reviewed. For instance,  some I/O modules provide for cold sparing; that is, they present high impedance to the system  when powered off. That same I/O, configured differently, may have clamp diodes switched in  while powered off for PCI compatibility. The design details are needed to do a worst-case  analysis.    meet PLD requirements. Startup current transients are common in many devices. The size of the  current can be a function of time between power cycles, temperature, ramp rate of the supply,  radiation exposure history, power supply sequencing, etc. These currents can be large for certain  devices, often as high as several amps. Ensure the power supply system does not limit current to  steady state levels because insufficient current during the startup sequence can result in a failure  to properly initialize, power device shutdown, recycling in an infinite loop, or a system lockup.  Similarly, some parts have restrictions on minimum and maximum power supply rise times.              ollow device datasheets and/or device application notes for proper decoupling. Perform a  power integrity analysis at the frequencies of operation. Logic devices can be rather large,  consisting of billions of gates. Synchronous design techniques, high operating frequencies, and  large I/O counts can result in a challenge to the power distribution and conditioning system.  Application notes contain most of the manufacturer\u2019s supply details. Follow these rules unless a  power integrity analysis and testing of the system for worst-case conditions reveal an alternate  course. Worst-case test patterns can be exploited to ensure high-fidelity power and then replaced  with the flight application. JTAG interfaces may also be used with care given that the JTAG test  patterns do not violate design limits, such as SSOs. Consider the aging effects of time and  radiation.       to complete a write access of non-volatile memories, if needed. In cases where non-volatile  memory protection is required, the PLD requirements specify the mitigations performed by the  PLD.   ndeterminate signals sourced from the PLD are a common problem for erasable non-volatile  memories. The analysis and test has to examine all of the signals for proper and safe operation  during power-up, power-down, and brown-out transients. Note that the real power supply and its  bounded characteristics has to be used, not laboratory supplies that most likely have substantially  different characteristics. Some devices have a reset pin to help protect against inadvertent writes.  The design, analysis, and test/evaluation of this circuit under all conditions are critical for  maintaining the integrity of the non-volatile memory contents. Consider circuit operation if the  power is shut down during either a planned or unexpected write cycle. The design needs to  ensure the proper completion of write cycles to protect the contents of the non-volatile memory.  The write cycle often includes the time for not only the bus operation to complete, but also for  writing to the internal part, which can take about 10 ms. Another related consideration is the  unexpected application of a system reset signal. Shutdown states are entered to help ensure that  write cycles are fully completed and properly shut down, with the critical signals put in a safe  mode.         mplement a mechanism to detect corrupted writes. The technology of the non-volatile memory  has to be carefully considered if the memory is to be written in flight. Some of these devices,  such as EEPROMs, use high voltage to write the cell. If struck by a heavy ion with high voltage  applied, the failure mode needs to be analyzed and dealt with appropriately. Thus, writing in  flight has to be considered a high-risk operation.    esign an interface to maximize useful life of memory. Many non-volatile erasable memories  have limited number of access cycles. Each device has to be treated on a case-by-case basis with  system lifetime and radiation factored in. For example, the 128k x 8 Hitachi die, for example,  has a lifetime write specification limit of 104 cycles in byte mode with 105 cycles in page mode.  The write mechanism for this device utilizes an 8-byte subpage as the smallest unit that can be  written. Therefore, writing the same memory space one byte at a time is more stressful than  page writes since entire subpages have to first be fetched and then re-written.   the signals interfacing with non-volatile memories be clean, that system noise be kept to a  minimum, and that they always meet all specifications. In this case, signals include not only  logic signals but also power and ground connections; therefore, robust bypassing needs to be  used. Noise glitches on EEPROMs, for example, can cause false write cycles to be generated,  resulting in inadvertent altering of the device\u2019s contents.   he required reliability of the non-volatile, erasable memory device is highly dependent on its  application. If the device operates as part of a large memory array, then some bit failures and  even page failures can be tolerated either by error correction techniques or by error detection and  mapping the failed segment out of service.  Another example is when the PLD is accessing memory. For single bit failures, a Hamming  code may suffice, although that may be awkward for serial PROMs. Some failure modes of non-  volatile memory devices may result in a bit oscillating or not providing a valid logic level; in this  case, an EDAC device may or may not correct the single bit error, depending on the logic design  of the EDAC device being used and whether or not it is static hazard free. In any event, the   esign interfaces to implement the required error detection and correction (EDAC). For  reprogrammable PLDs that are configured, it is a best practice to maintain a non-changeable  memory like programmable read-only memory (PROM) that can be switched on if the  configuration memory fails.          devices employed, combined with the architecture of the particular system, have to ensure that  there are no lockup states from any credible failures. Credible failures include any single bit  error and an inadvertent corruption of a non-permanent memory\u2019s contents.   options include the ability to switch in alternate devices, the use of permanent memory such as  PROM, or the use of storage buffers to replace erasable non-volatile memory functions, using  operational overhead to manage the risk. For example, if a configuration memory device for a  PLD fails, a storage buffer and CPU may configure the PLD using a different loading mode,  assuming that, of course, the PLD is not needed to run the computer. In general, for critical  applications, permanent memories, such as PROM, are to be used to ensure that the spacecraft or  other system cannot be permanently lost. This can take the form of boot and safe-hold code for a  processor or a basic operating configuration for a PLD.  retention against mission life. Another consideration is the guaranteed storage time of the device  versus mission length. Each device has to be analyzed on a case-by-case basis. Ten years is a  frequent specification for the retention of memory contents; however, system lifetimes of several  decades is not uncommon.   Refreshing can be risky. The usefulness of it has to be verified with the manufacturer\u2019s  assistance, to ensure a guarantee of storage integrity, particularly in the radiation environment.  When the device is refreshed, it may be susceptible to damage in the space environment by  heavy ions. Other errors can occur that damage the contents, such as a computer crash, brown  out, or the unexpected removal of power due to a bus fault or a spacecraft entering a safe mode.  In addition, each write cycle takes away from the operational lifetime of the component.   f applicable to the design, consider the following board design activities to ensure adequate and  robust noise immunity:      devices are directly supporting differential standards. Additionally, high-speed, lower power  differential devices support standards, such as LVDS, are now qualified.                   to a valid logic \u20181\u2019 with sufficient noise immunity. Calculate worst-case currents and voltage  output versus worst-case input thresholds. Use level shifters as needed.       t is advisable to consider credible but unplanned events. Often many of these situations can be  economically handled with some planning. Following are a few sample activities to consider:   a. Perform limit and validity checking. The system needs to respond in a reasonable  fashion to unexpected input states. For data passed from one source to another, simple bounds  checks can detect and cause appropriate action for many off-nominal conditions, such as a  disconnected source. This may result in all Fs being returned on a data bus. For floating point  numbers, determine whether the input in a valid format. A minimum criterion is that any  credible input does not damage hardware and prevent recovery. Assume that the probability of  software failure is 100 percent.   wire breaks in a connector, for each wire. For power, use multiple wires such that if any one  wire breaks the remaining set can carry the load (and be sure to test this redundancy). For  signals, consider on-board terminations that pull floating signals into a safe and operational state.  This can also provide protection if the board or subsystem is powered with a connector not  hooked up, perhaps by test error. Avoid putting signals such as power and ground on adjacent  pins, as a short can take out the system.                      Follow manufacturer\u2019s recommendation for grounding the PLD lid. The lid may need grounding  to ensure that there is no buildup of charges. Doing this prevents ESD events.                 GSFC Assurance Activities for Digital Electronics for  Spacecraft, Instruments, and Launch Vehicles  GSFC Design of Space Flight Field-Programmable Gate  Arrays  GSFC Field-Programmable Gate Array (FPGA) Development  Methodology         Marshall Space Flight Center (MSFC) Standard for  Configurable Logic Device Developments                                  "}